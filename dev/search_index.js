var documenterSearchIndex = {"docs":
[{"location":"submissions/#List-of-submissions","page":"List of submissions","title":"List of submissions","text":"","category":"section"},{"location":"submissions/","page":"List of submissions","title":"List of submissions","text":"It follows the code and plot of the RainGauge of all RainMaker submissions to /submissions sorted in alphabetical order of the filename.","category":"page"},{"location":"submissions/#A-Nicusan:-Evo-opt-unbounded-(disqualified)","page":"List of submissions","title":"A Nicusan: Evo opt unbounded (disqualified)","text":"","category":"section"},{"location":"submissions/","page":"List of submissions","title":"List of submissions","text":"path: /submissions/anicusan_evoopt_unbounded.jl","category":"page"},{"location":"submissions/","page":"List of submissions","title":"List of submissions","text":"rank: 1. of 14 submissions","category":"page"},{"location":"submissions/","page":"List of submissions","title":"List of submissions","text":"using CairoMakie # hide\nauthor = \"A Nicusan\"\ndescription = \"Evo opt unbounded (disqualified)\"\n\nusing SpeedyWeather, RainMaker\n\nconst PARAMETER_KEYS = (\n    :orography_scale,           # [1],      default: 1, scale of global orography\n    :mountain_height,           # [m],      default: 0, height of an additional mountain\n    :mountain_size,             # [˚],      default: 1, horizontal size of mountain\n    :mountain_lon,              # [˚E],     default: -80, longitude of that mountain\n    :mountain_lat,              # [˚N],     default: 40.45, latitude of that mountain\n    :temperature_equator,       # [K],      default: 300, sea surface temperature at the equator\n    :temperature_pole,          # [K],      default: 273, sea surfaec temperature at the poles\n    :temperature_usa,           # [K],      default: 0, land surface temperature anomaly over the USA\n    :temperature_pa,            # [K],      default: 0, land surface temperature anomaly in Pennsylvania\n    :zonal_wind,                # [m/s],    default: 35, zonal wind speed\n)\n\nconst PARAMETER_DEFAULTS = [1, 0, 1, -80, 40.45, 300, 273, 0, 0, 35]\n\nfunction max_precipitation(parameters::AbstractVector)\n    parameter_tuple = NamedTuple{PARAMETER_KEYS}(parameters)\n    return max_precipitation(parameter_tuple)\nend\n\nfunction max_precipitation(parameters::NamedTuple)\n\n    # define resolution. Use trunc=42, 63, 85, 127, ... for higher resolution, cubically slower\n    spectral_grid = SpectralGrid(trunc=31, nlayers=8)\n\n    # Define AquaPlanet ocean, for idealised sea surface temperatures\n    # but don't change land-sea mask = retain real ocean basins\n    ocean = AquaPlanet(spectral_grid,\n                temp_equator=parameters.temperature_equator,\n                temp_poles=parameters.temperature_pole)\n\n    land_temperature = ConstantLandTemperature(spectral_grid)\n    land = LandModel(spectral_grid; temperature=land_temperature)\n\n    initial_conditions = InitialConditions(\n        vordiv = ZonalWind(u₀=parameters.zonal_wind),\n        temp = JablonowskiTemperature(u₀=parameters.zonal_wind),\n        pres = PressureOnOrography(),\n        humid = ConstantRelativeHumidity())\n\n    orography = EarthOrography(spectral_grid, scale=parameters.orography_scale)\n\n    # construct model\n    model = PrimitiveWetModel(spectral_grid; ocean, land, initial_conditions, orography)\n\n    # Add rain gauge, locate in Pittsburgh PA\n    rain_gauge = RainGauge(spectral_grid, lond=-80, latd=40.45)\n    add!(model, rain_gauge)\n\n    # Initialize\n    simulation = initialize!(model, time=DateTime(2025, 7, 22))\n\n    # Add additional  mountain\n    H = parameters.mountain_height\n    λ₀, φ₀, σ = parameters.mountain_lon, parameters.mountain_lat, parameters.mountain_size  \n    set!(model, orography=(λ,φ) -> H*exp(-spherical_distance((λ,φ), (λ₀,φ₀), radius=360/2π)^2/2σ^2), add=true)\n\n    # land sea surface temperature anomalies\n    # 1. USA\n    set!(simulation, soil_temperature=\n        (λ, φ, k) -> (30 < φ < 50) && (240 < λ < 285) ? parameters.temperature_usa : 0, add=true)\n\n    # 2. Pennsylvania\n    A = parameters.temperature_pa\n    λ_az, φ_az, σ_az = -80, 40.45, 4    # location [˚], size [˚] of Azores\n    set!(simulation, soil_temperature=\n        (λ, φ, k) -> A*exp(-spherical_distance((λ,φ), (λ_az,φ_az), radius=360/2π)^2/2σ_az^2), add=true)\n\n    # Run simulation for 20 days\n    run!(simulation, period=Day(20))\n\n    # skip first 5 days, as is done in the RainMaker challenge\n    RainMaker.skip!(rain_gauge, Day(5))\n\n    # evaluate rain gauge\n    lsc = rain_gauge.accumulated_rain_large_scale\n    conv = rain_gauge.accumulated_rain_convection\n    total_precip = maximum(lsc) + maximum(conv)\n    return rain_gauge, total_precip\nend\n\nbest_params = [\n    1.680189,\n    240.442519,\n    10.640524,\n    166.748171,\n    60.635959,\n    256.528781,\n    268.849961,\n    18.577591,\n    19.591949,\n    30.854462,\n]\n\nrain_gauge, total_precip = max_precipitation(best_params)\nRainMaker.plot(rain_gauge, skip=Day(5)) # hide\nsave(\"submission_anicusan_evoopt_unbounded.png\", ans) # hide\nnothing # hide","category":"page"},{"location":"submissions/","page":"List of submissions","title":"List of submissions","text":"(Image: submission: anicusan_evoopt_unbounded)","category":"page"},{"location":"submissions/#A-Nicusan:-Evo-opt-bounded","page":"List of submissions","title":"A Nicusan: Evo opt bounded","text":"","category":"section"},{"location":"submissions/","page":"List of submissions","title":"List of submissions","text":"path: /submissions/anicusan_evoopt_bounded.jl","category":"page"},{"location":"submissions/","page":"List of submissions","title":"List of submissions","text":"rank: 2. of 14 submissions","category":"page"},{"location":"submissions/","page":"List of submissions","title":"List of submissions","text":"using CairoMakie # hide\nauthor = \"A Nicusan\"\ndescription = \"Evo opt bounded\"\n\nusing SpeedyWeather, RainMaker\n\nconst PARAMETER_KEYS = (\n    :orography_scale,           # [1],      default: 1, scale of global orography\n    :mountain_height,           # [m],      default: 0, height of an additional mountain\n    :mountain_size,             # [˚],      default: 1, horizontal size of mountain\n    :mountain_lon,              # [˚E],     default: -80, longitude of that mountain\n    :mountain_lat,              # [˚N],     default: 40.45, latitude of that mountain\n    :temperature_equator,       # [K],      default: 300, sea surface temperature at the equator\n    :temperature_pole,          # [K],      default: 273, sea surfaec temperature at the poles\n    :temperature_usa,           # [K],      default: 0, land surface temperature anomaly over the USA\n    :temperature_pa,            # [K],      default: 0, land surface temperature anomaly in Pennsylvania\n    :zonal_wind,                # [m/s],    default: 35, zonal wind speed\n)\n\nconst PARAMETER_DEFAULTS = [1, 0, 1, -80, 40.45, 300, 273, 0, 0, 35]\n\nfunction max_precipitation(parameters::AbstractVector)\n    parameter_tuple = NamedTuple{PARAMETER_KEYS}(parameters)\n    return max_precipitation(parameter_tuple)\nend\n\nfunction max_precipitation(parameters::NamedTuple)\n\n    # define resolution. Use trunc=42, 63, 85, 127, ... for higher resolution, cubically slower\n    spectral_grid = SpectralGrid(trunc=31, nlayers=8)\n\n    # Define AquaPlanet ocean, for idealised sea surface temperatures\n    # but don't change land-sea mask = retain real ocean basins\n    ocean = AquaPlanet(spectral_grid,\n                temp_equator=parameters.temperature_equator,\n                temp_poles=parameters.temperature_pole)\n\n    land_temperature = ConstantLandTemperature(spectral_grid)\n    land = LandModel(spectral_grid; temperature=land_temperature)\n\n    initial_conditions = InitialConditions(\n        vordiv = ZonalWind(u₀=parameters.zonal_wind),\n        temp = JablonowskiTemperature(u₀=parameters.zonal_wind),\n        pres = PressureOnOrography(),\n        humid = ConstantRelativeHumidity())\n\n    orography = EarthOrography(spectral_grid, scale=parameters.orography_scale)\n\n    # construct model\n    model = PrimitiveWetModel(spectral_grid; ocean, land, initial_conditions, orography)\n\n    # Add rain gauge, locate in Pittsburgh PA\n    rain_gauge = RainGauge(spectral_grid, lond=-80, latd=40.45)\n    add!(model, rain_gauge)\n\n    # Initialize\n    simulation = initialize!(model, time=DateTime(2025, 7, 22))\n\n    # Add additional  mountain\n    H = parameters.mountain_height\n    λ₀, φ₀, σ = parameters.mountain_lon, parameters.mountain_lat, parameters.mountain_size  \n    set!(model, orography=(λ,φ) -> H*exp(-spherical_distance((λ,φ), (λ₀,φ₀), radius=360/2π)^2/2σ^2), add=true)\n\n    # land sea surface temperature anomalies\n    # 1. USA\n    set!(simulation, soil_temperature=\n        (λ, φ, k) -> (30 < φ < 50) && (240 < λ < 285) ? parameters.temperature_usa : 0, add=true)\n\n    # 2. Pennsylvania\n    A = parameters.temperature_pa\n    λ_az, φ_az, σ_az = -80, 40.45, 4    # location [˚], size [˚] of Azores\n    set!(simulation, soil_temperature=\n        (λ, φ, k) -> A*exp(-spherical_distance((λ,φ), (λ_az,φ_az), radius=360/2π)^2/2σ_az^2), add=true)\n\n    # Run simulation for 20 days\n    run!(simulation, period=Day(20))\n\n    # skip first 5 days, as is done in the RainMaker challenge\n    RainMaker.skip!(rain_gauge, Day(5))\n\n    # evaluate rain gauge\n    lsc = rain_gauge.accumulated_rain_large_scale\n    conv = rain_gauge.accumulated_rain_convection\n    total_precip = maximum(lsc) + maximum(conv)\n    return rain_gauge, total_precip\nend\n\nbest_params = [\n    1.999196,\n    2304.509728,\n    14.889662,\n    74.446324,\n    -70.338707,\n    280.224610,\n    299.998274,\n    4.999593,\n    4.996833,\n    33.312800,\n]\n\nrain_gauge, total_precip = max_precipitation(best_params)\n\nRainMaker.plot(rain_gauge, skip=Day(5)) # hide\nsave(\"submission_anicusan_evoopt_bounded.png\", ans) # hide\nnothing # hide","category":"page"},{"location":"submissions/","page":"List of submissions","title":"List of submissions","text":"(Image: submission: anicusan_evoopt_bounded)","category":"page"},{"location":"submissions/#Chris-Rackauckas:-Brute-Force-OptimizationBBO-DE","page":"List of submissions","title":"Chris Rackauckas: Brute Force OptimizationBBO DE","text":"","category":"section"},{"location":"submissions/","page":"List of submissions","title":"List of submissions","text":"path: /submissions/chris_brute_force.jl","category":"page"},{"location":"submissions/","page":"List of submissions","title":"List of submissions","text":"rank: 3. of 14 submissions","category":"page"},{"location":"submissions/","page":"List of submissions","title":"List of submissions","text":"using CairoMakie # hide\nauthor = \"Chris Rackauckas\"\ndescription = \"Brute Force OptimizationBBO DE\"\n\n#=\nusing RainMakerChallenge2025\nusing OptimizationBBO, Optimization\n\nfunction objective(params, p)\n    return -max_precipitation(params)\nend\n\nlower_bounds = [0., -2000., 0., -180., -90., 270., 270., -5., -5., 5.]\nupper_bounds = [2., 5000., 30., 180., 90., 300., 300., 5., 5., 50.]\n\noptf = OptimizationFunction(objective)\nprob = Optimization.OptimizationProblem(optf, [1, 0, 1, -80, 40.45, 300, 273, 0, 0, 35], \n                          lb=lower_bounds, ub=upper_bounds)\n\nprintln(\"Starting optimization...\")\nsol = solve(prob, BBO_adaptive_de_rand_1_bin_radiuslimited(); maxiters=10_000)\n\nprintln(\"Optimized parameters: \", sol.u)\nprintln(\"Predicted max precipitation from surrogate: \", max_precipitation(sol.u))\n=#\n\nusing SpeedyWeather, RainMaker\n\n\nconst PARAMETER_KEYS = (\n    :orography_scale,           # [1],      default: 1, scale of global orography\n    :mountain_height,           # [m],      default: 0, height of an additional azores mountain\n    :mountain_size,             # [˚],      default: 1, horizontal size of mountain in Pittsburgh\n    :mountain_lon,              # [˚E],     default: -80, longitude of that mountain in Pittsburgh\n    :mountain_lat,              # [˚N],     default: 40.45, latitude of that mountain in Pittsburgh\n    :temperature_equator,       # [K],      default: 300, sea surface temperature at the equator\n    :temperature_pole,          # [K],      default: 273, sea surfaec temperature at the poles\n    :temperature_usa,           # [K],      default: 0, land surface temperature anomaly over the USA\n    :temperature_pa,            # [K],      default: 0, land surface temperature anomaly in Pennsylvania\n    :zonal_wind,                # [m/s],    default: 35, zonal wind speed\n)\n\nconst PARAMETER_DEFAULTS = [1, 0, 1, -80, 40.45, 300, 273, 0, 0, 35]\n\nfunction max_precipitation(parameters::AbstractVector)\n    parameter_tuple = NamedTuple{PARAMETER_KEYS}(parameters)\n    return max_precipitation(parameter_tuple)\nend\n\nfunction max_precipitation(parameters::NamedTuple)\n\n    # define resolution. Use trunc=42, 63, 85, 127, ... for higher resolution, cubically slower\n    spectral_grid = SpectralGrid(trunc=31, nlayers=8)\n\n    # Define AquaPlanet ocean, for idealised sea surface temperatures\n    # but don't change land-sea mask = retain real ocean basins\n    ocean = AquaPlanet(spectral_grid,\n                temp_equator=parameters.temperature_equator,\n                temp_poles=parameters.temperature_pole)\n\n    land_temperature = ConstantLandTemperature(spectral_grid)\n    land = LandModel(spectral_grid; temperature=land_temperature)\n\n    initial_conditions = InitialConditions(\n        vordiv = ZonalWind(u₀=parameters.zonal_wind),\n        temp = JablonowskiTemperature(u₀=parameters.zonal_wind),\n        pres = PressureOnOrography(),\n        humid = ConstantRelativeHumidity())\n\n    orography = EarthOrography(spectral_grid, scale=parameters.orography_scale)\n\n    # construct model\n    model = PrimitiveWetModel(spectral_grid; ocean, land, initial_conditions, orography)\n\n    # Add rain gauge, locate in Pittsburgh PA\n    rain_gauge = RainGauge(spectral_grid, lond=-80, latd=40.45)\n    add!(model, rain_gauge)\n\n    # Initialize\n    simulation = initialize!(model, time=DateTime(2025, 7, 22))\n\n    # Add additional  mountain\n    H = parameters.mountain_height\n    λ₀, φ₀, σ = parameters.mountain_lon, parameters.mountain_lat, parameters.mountain_size  \n    set!(model, orography=(λ,φ) -> H*exp(-spherical_distance((λ,φ), (λ₀,φ₀), radius=360/2π)^2/2σ^2), add=true)\n\n    # land sea surface temperature anomalies\n    # 1. USA\n    set!(simulation, soil_temperature=\n        (λ, φ, k) -> (30 < φ < 50) && (240 < λ < 285) ? parameters.temperature_usa : 0, add=true)\n\n    # 2. Pennsylvania\n    A = parameters.temperature_pa\n    λ_az, φ_az, σ_az = -80, 40.45, 4    # location [˚], size [˚] of Azores\n    set!(simulation, soil_temperature=\n        (λ, φ, k) -> A*exp(-spherical_distance((λ,φ), (λ_az,φ_az), radius=360/2π)^2/2σ_az^2), add=true)\n\n    # Run simulation for 20 days\n    run!(simulation, period=Day(20))\n\n    # skip first 5 days, as is done in the RainMaker challenge\n    RainMaker.skip!(rain_gauge, Day(5))\n\n    # evaluate rain gauge\n    lsc = rain_gauge.accumulated_rain_large_scale\n    conv = rain_gauge.accumulated_rain_convection\n    total_precip = maximum(lsc) + maximum(conv)\n    return rain_gauge, total_precip\nend\n\nfinal_params = [1.9851412873870289, 2485.737125917869, 14.118878320714353, 73.66989910502846, -72.40588406991382, 280.9029383973223, 299.2432527466829, 4.773285514316327, 4.586811470190235, 33.398388938656204]\n\nrain_gauge, total_precip = max_precipitation(final_params)\n\ntotal_precip\n\nRainMaker.plot(rain_gauge, skip=Day(5)) # hide\nsave(\"submission_chris_brute_force.png\", ans) # hide\nnothing # hide","category":"page"},{"location":"submissions/","page":"List of submissions","title":"List of submissions","text":"(Image: submission: chris_brute_force)","category":"page"},{"location":"submissions/#Anas:-NN-Surrogate","page":"List of submissions","title":"Anas: NN Surrogate","text":"","category":"section"},{"location":"submissions/","page":"List of submissions","title":"List of submissions","text":"path: /submissions/anas-nn_surrogate_v2.jl","category":"page"},{"location":"submissions/","page":"List of submissions","title":"List of submissions","text":"rank: 4. of 14 submissions","category":"page"},{"location":"submissions/","page":"List of submissions","title":"List of submissions","text":"using CairoMakie # hide\nauthor = \"Anas\"\ndescription = \"NN Surrogate\"\n\nusing SpeedyWeather, RainMaker\n\n\nconst PARAMETER_KEYS = (\n    :orography_scale,           # [1],      default: 1, scale of global orography\n    :mountain_height,           # [m],      default: 0, height of an additional azores mountain\n    :mountain_size,             # [˚],      default: 1, horizontal size of mountain in Pittsburgh\n    :mountain_lon,              # [˚E],     default: -80, longitude of that mountain in Pittsburgh\n    :mountain_lat,              # [˚N],     default: 40.45, latitude of that mountain in Pittsburgh\n    :temperature_equator,       # [K],      default: 300, sea surface temperature at the equator\n    :temperature_pole,          # [K],      default: 273, sea surfaec temperature at the poles\n    :temperature_usa,           # [K],      default: 0, land surface temperature anomaly over the USA\n    :temperature_pa,            # [K],      default: 0, land surface temperature anomaly in Pennsylvania\n    :zonal_wind,                # [m/s],    default: 35, zonal wind speed\n)\n\nconst PARAMETER_DEFAULTS = [1, 0, 1, -80, 40.45, 300, 273, 0, 0, 35]\n\nfunction max_precipitation(parameters::AbstractVector)\n    parameter_tuple = NamedTuple{PARAMETER_KEYS}(parameters)\n    return max_precipitation(parameter_tuple)\nend\n\nfunction max_precipitation(parameters::NamedTuple)\n\n    # define resolution. Use trunc=42, 63, 85, 127, ... for higher resolution, cubically slower\n    spectral_grid = SpectralGrid(trunc=31, nlayers=8)\n\n    # Define AquaPlanet ocean, for idealised sea surface temperatures\n    # but don't change land-sea mask = retain real ocean basins\n    ocean = AquaPlanet(spectral_grid,\n                temp_equator=parameters.temperature_equator,\n                temp_poles=parameters.temperature_pole)\n\n    land_temperature = ConstantLandTemperature(spectral_grid)\n    land = LandModel(spectral_grid; temperature=land_temperature)\n\n    initial_conditions = InitialConditions(\n        vordiv = ZonalWind(u₀=parameters.zonal_wind),\n        temp = JablonowskiTemperature(u₀=parameters.zonal_wind),\n        pres = PressureOnOrography(),\n        humid = ConstantRelativeHumidity())\n\n    orography = EarthOrography(spectral_grid, scale=parameters.orography_scale)\n\n    # construct model\n    model = PrimitiveWetModel(spectral_grid; ocean, land, initial_conditions, orography)\n\n    # Add rain gauge, locate in Pittsburgh PA\n    rain_gauge = RainGauge(spectral_grid, lond=-80, latd=40.45)\n    add!(model, rain_gauge)\n\n    # Initialize\n    simulation = initialize!(model, time=DateTime(2025, 7, 22))\n\n    # Add additional  mountain\n    H = parameters.mountain_height\n    λ₀, φ₀, σ = parameters.mountain_lon, parameters.mountain_lat, parameters.mountain_size  \n    set!(model, orography=(λ,φ) -> H*exp(-spherical_distance((λ,φ), (λ₀,φ₀), radius=360/2π)^2/2σ^2), add=true)\n\n    # land sea surface temperature anomalies\n    # 1. USA\n    set!(simulation, soil_temperature=\n        (λ, φ, k) -> (30 < φ < 50) && (240 < λ < 285) ? parameters.temperature_usa : 0, add=true)\n\n    # 2. Pennsylvania\n    A = parameters.temperature_pa\n    λ_az, φ_az, σ_az = -80, 40.45, 4    # location [˚], size [˚] of Azores\n    set!(simulation, soil_temperature=\n        (λ, φ, k) -> A*exp(-spherical_distance((λ,φ), (λ_az,φ_az), radius=360/2π)^2/2σ_az^2), add=true)\n\n    # Run simulation for 20 days\n    run!(simulation, period=Day(20))\n\n    # skip first 5 days, as is done in the RainMaker challenge\n    RainMaker.skip!(rain_gauge, Day(5))\n\n    # evaluate rain gauge\n    lsc = rain_gauge.accumulated_rain_large_scale\n    conv = rain_gauge.accumulated_rain_convection\n    total_precip = maximum(lsc) + maximum(conv)\n    return rain_gauge, total_precip\nend\n\nfinal_params = \n[    1.1229311227798462,\n 3772.9730010032654,\n    4.986201524734497,\n -120.26883065700531,\n   49.61676836013794,\n  276.7463958263397,\n  282.4692580103874,\n    4.013188481330872,\n    3.889443278312683,\n   26.725226491689682 ]\n\nrain_gauge, total_precip = max_precipitation(final_params)\n\ntotal_precip\n\nRainMaker.plot(rain_gauge, skip=Day(5)) # hide\nsave(\"submission_anas-nn_surrogate_v2.png\", ans) # hide\nnothing # hide","category":"page"},{"location":"submissions/","page":"List of submissions","title":"List of submissions","text":"(Image: submission: anas-nn_surrogate_v2)","category":"page"},{"location":"submissions/#Anas:-200mm-RainMaker","page":"List of submissions","title":"Anas: 200mm+ RainMaker","text":"","category":"section"},{"location":"submissions/","page":"List of submissions","title":"List of submissions","text":"path: /submissions/anas_submission.jl","category":"page"},{"location":"submissions/","page":"List of submissions","title":"List of submissions","text":"rank: 5. of 14 submissions","category":"page"},{"location":"submissions/","page":"List of submissions","title":"List of submissions","text":"using CairoMakie # hide\nauthor = \"Anas\"\ndescription = \"200mm+ RainMaker\"\n\nusing SpeedyWeather, RainMaker\n\n\nconst PARAMETER_KEYS = (\n    :orography_scale,           # [1],      default: 1, scale of global orography\n    :mountain_height,           # [m],      default: 0, height of an additional azores mountain\n    :mountain_size,             # [˚],      default: 1, horizontal size of mountain in Pittsburgh\n    :mountain_lon,              # [˚E],     default: -80, longitude of that mountain in Pittsburgh\n    :mountain_lat,              # [˚N],     default: 40.45, latitude of that mountain in Pittsburgh\n    :temperature_equator,       # [K],      default: 300, sea surface temperature at the equator\n    :temperature_pole,          # [K],      default: 273, sea surfaec temperature at the poles\n    :temperature_usa,           # [K],      default: 0, land surface temperature anomaly over the USA\n    :temperature_pa,            # [K],      default: 0, land surface temperature anomaly in Pennsylvania\n    :zonal_wind,                # [m/s],    default: 35, zonal wind speed\n)\n\nconst PARAMETER_DEFAULTS = [1, 0, 1, -80, 40.45, 300, 273, 0, 0, 35]\n\nfunction max_precipitation(parameters::AbstractVector)\n    parameter_tuple = NamedTuple{PARAMETER_KEYS}(parameters)\n    return max_precipitation(parameter_tuple)\nend\n\nfunction max_precipitation(parameters::NamedTuple)\n\n    # define resolution. Use trunc=42, 63, 85, 127, ... for higher resolution, cubically slower\n    spectral_grid = SpectralGrid(trunc=31, nlayers=8)\n\n    # Define AquaPlanet ocean, for idealised sea surface temperatures\n    # but don't change land-sea mask = retain real ocean basins\n    ocean = AquaPlanet(spectral_grid,\n                temp_equator=parameters.temperature_equator,\n                temp_poles=parameters.temperature_pole)\n\n    land_temperature = ConstantLandTemperature(spectral_grid)\n    land = LandModel(spectral_grid; temperature=land_temperature)\n\n    initial_conditions = InitialConditions(\n        vordiv = ZonalWind(u₀=parameters.zonal_wind),\n        temp = JablonowskiTemperature(u₀=parameters.zonal_wind),\n        pres = PressureOnOrography(),\n        humid = ConstantRelativeHumidity())\n\n    orography = EarthOrography(spectral_grid, scale=parameters.orography_scale)\n\n    # construct model\n    model = PrimitiveWetModel(spectral_grid; ocean, land, initial_conditions, orography)\n\n    # Add rain gauge, locate in Pittsburgh PA\n    rain_gauge = RainGauge(spectral_grid, lond=-80, latd=40.45)\n    add!(model, rain_gauge)\n\n    # Initialize\n    simulation = initialize!(model, time=DateTime(2025, 7, 22))\n\n    # Add additional  mountain\n    H = parameters.mountain_height\n    λ₀, φ₀, σ = parameters.mountain_lon, parameters.mountain_lat, parameters.mountain_size  \n    set!(model, orography=(λ,φ) -> H*exp(-spherical_distance((λ,φ), (λ₀,φ₀), radius=360/2π)^2/2σ^2), add=true)\n\n    # land sea surface temperature anomalies\n    # 1. USA\n    set!(simulation, soil_temperature=\n        (λ, φ, k) -> (30 < φ < 50) && (240 < λ < 285) ? parameters.temperature_usa : 0, add=true)\n\n    # 2. Pennsylvania\n    A = parameters.temperature_pa\n    λ_az, φ_az, σ_az = -80, 40.45, 4    # location [˚], size [˚] of Azores\n    set!(simulation, soil_temperature=\n        (λ, φ, k) -> A*exp(-spherical_distance((λ,φ), (λ_az,φ_az), radius=360/2π)^2/2σ_az^2), add=true)\n\n    # Run simulation for 20 days\n    run!(simulation, period=Day(20))\n\n    # skip first 5 days, as is done in the RainMaker challenge\n    RainMaker.skip!(rain_gauge, Day(5))\n\n    # evaluate rain gauge\n    lsc = rain_gauge.accumulated_rain_large_scale\n    conv = rain_gauge.accumulated_rain_convection\n    total_precip = maximum(lsc) + maximum(conv)\n    return rain_gauge, total_precip\nend\n\nfinal_params = \n[2.0163631439208984,\n5013.73028755188,\n-0.017217400018125772,\n-22.203487157821655,\n-19.583306908607483,\n282.971847653389,\n300.2009081840515,\n2.134748101234436,\n4.705338478088379,\n34.92057800292969 ]\n\nrain_gauge, total_precip = max_precipitation(final_params)\n\ntotal_precip\n\nRainMaker.plot(rain_gauge, skip=Day(5)) # hide\nsave(\"submission_anas_submission.png\", ans) # hide\nnothing # hide","category":"page"},{"location":"submissions/","page":"List of submissions","title":"List of submissions","text":"(Image: submission: anas_submission)","category":"page"},{"location":"submissions/#Gabriel-Konar-Steenberg:-Brute-force-built-on-Anas-surrogate","page":"List of submissions","title":"Gabriel Konar-Steenberg: Brute force built on Anas surrogate","text":"","category":"section"},{"location":"submissions/","page":"List of submissions","title":"List of submissions","text":"path: /submissions/gabrielks_brute_force_1.jl","category":"page"},{"location":"submissions/","page":"List of submissions","title":"List of submissions","text":"rank: 6. of 14 submissions","category":"page"},{"location":"submissions/","page":"List of submissions","title":"List of submissions","text":"using CairoMakie # hide\nauthor = \"Gabriel Konar-Steenberg\"\ndescription = \"Brute force built on Anas surrogate\"\n\nusing SpeedyWeather, RainMaker\n\n\"\"\"\nQuickly written code based on\nhttps://github.com/AnasAbdelR/RainMakerChallenge2025.jl/blob/main/examples/surrogate_nn_ex.jl.\nWe load the pretrained surrogate model and do a brute force search over many optimization\nstarting points for the one that results in the best performance on the real model.\n\"\"\"\n#=\nusing JLSO\nusing LinearAlgebra\nusing Distributions\nusing NNlib\nusing Random\nusing Optimization\nusing OptimizationOptimJL\nusing Flux\nusing SpeedyWeather\nusing RainMaker\nusing RainMakerChallenge2025\nusing Logging\n\nminmaxnorm(data, lb, ub, norm_min=0., norm_max=1.) = @. norm_min + (data - lb) * (norm_max - norm_min) / (ub - lb)\nminmaxdenorm(data, lb, ub, norm_min=0., norm_max=1.) = @. lb + (data - norm_min) * (ub - lb) / (norm_max - norm_min)\n\nfunction outer_iter(seed)\n    path = joinpath(@__DIR__, \"data\", \"10kdata.jlso\")\n    data = JLSO.load(path)\n    output_data = data[:d][:outputs]\n\n    inputs_lb = [0., -2000., 0., -180., -90., 270., 270., -5., -5., 5.]\n    inputs_ub = [2., 5000., 30., 180., 90., 300., 300., 5., 5., 50.]\n\n    output_data = reshape(output_data, (1,:))\n    outputs_lb, outputs_ub = extrema(output_data)\n\n    # Load the surrogate model\n    path = joinpath(@__DIR__, \"models\", \"surrogate_nn_ex_128_500-v2.jlso\")\n    surrogate = JLSO.load(path)[:surrogate]\n\n    # Simple SciML Optimization equivalent\n    function objective_func_simple(x, p)\n        X = reshape(x, 10, :) |> gpu  # Same as your Flux code\n        y_pred = surrogate(X)\n        obj = -sum(y_pred)  # Same objective\n        λ = 100.0f0\n        lower_violation = max.(0.0f0, -x)\n        upper_violation = max.(0.0f0, x .- 1.0f0)\n        penalty = λ * (sum(lower_violation.^2) + sum(upper_violation.^2))\n        return obj + penalty\n    end\n\n    # Same initial setup as your Flux code\n    Random.seed!(seed)\n    x0 = vec(rand(Float32, 10, 10))  # Flatten to vector for Optimization.jl\n    optf = Optimization.OptimizationFunction(objective_func_simple, Optimization.AutoZygote())\n    prob = Optimization.OptimizationProblem(optf, x0)\n\n    # println(\"Starting SciML optimization (1000 samples)...\")\n    sol = solve(prob, LBFGS(), maxiters=20000)\n\n    # Extract results exactly like your Flux code\n    X_candidate_sciml = reshape(sol.u, 10, :) |> gpu\n    idx = argmax(surrogate(X_candidate_sciml))\n    best_param_sample_sciml = minmaxdenorm(X_candidate_sciml[:,idx[2]]|>cpu, inputs_lb, inputs_ub)\n    # @show best_param_sample_sciml\n    pred_vals_sciml = minmaxdenorm(surrogate(X_candidate_sciml)[:,idx[2]]|>cpu, outputs_lb, outputs_ub)\n    # @show pred_vals_sciml\n    actual_precip_sciml = max_precipitation(best_param_sample_sciml)\n    # @show actual_precip_sciml\n    return best_param_sample_sciml, pred_vals_sciml, actual_precip_sciml\nend\n\nfunction main()\n    global_logger(SimpleLogger(stderr, Logging.Warn))\n    Threads.@threads for i in 1:1000\n        best_param_sample_sciml, pred_vals_sciml, actual_precip_sciml = outer_iter(i)\n        println(\"Iteration $i\")\n        if actual_precip_sciml > 210.0\n            println(\"Best Parameters: $best_param_sample_sciml\\nPredicted Values: $pred_vals_sciml\\nActual Precipitation: $actual_precip_sciml\")\n        end\n    end\nend\n\nmain()\n=#\n\n\nconst PARAMETER_KEYS = (\n    :orography_scale,           # [1],      default: 1, scale of global orography\n    :mountain_height,           # [m],      default: 0, height of an additional azores mountain\n    :mountain_size,             # [˚],      default: 1, horizontal size of mountain in Pittsburgh\n    :mountain_lon,              # [˚E],     default: -80, longitude of that mountain in Pittsburgh\n    :mountain_lat,              # [˚N],     default: 40.45, latitude of that mountain in Pittsburgh\n    :temperature_equator,       # [K],      default: 300, sea surface temperature at the equator\n    :temperature_pole,          # [K],      default: 273, sea surfaec temperature at the poles\n    :temperature_usa,           # [K],      default: 0, land surface temperature anomaly over the USA\n    :temperature_pa,            # [K],      default: 0, land surface temperature anomaly in Pennsylvania\n    :zonal_wind,                # [m/s],    default: 35, zonal wind speed\n)\n\nconst PARAMETER_DEFAULTS = [1, 0, 1, -80, 40.45, 300, 273, 0, 0, 35]\n\nfunction max_precipitation(parameters::AbstractVector)\n    parameter_tuple = NamedTuple{PARAMETER_KEYS}(parameters)\n    return max_precipitation(parameter_tuple)\nend\n\nfunction max_precipitation(parameters::NamedTuple)\n\n    # define resolution. Use trunc=42, 63, 85, 127, ... for higher resolution, cubically slower\n    spectral_grid = SpectralGrid(trunc=31, nlayers=8)\n\n    # Define AquaPlanet ocean, for idealised sea surface temperatures\n    # but don't change land-sea mask = retain real ocean basins\n    ocean = AquaPlanet(spectral_grid,\n                temp_equator=parameters.temperature_equator,\n                temp_poles=parameters.temperature_pole)\n\n    land_temperature = ConstantLandTemperature(spectral_grid)\n    land = LandModel(spectral_grid; temperature=land_temperature)\n\n    initial_conditions = InitialConditions(\n        vordiv = ZonalWind(u₀=parameters.zonal_wind),\n        temp = JablonowskiTemperature(u₀=parameters.zonal_wind),\n        pres = PressureOnOrography(),\n        humid = ConstantRelativeHumidity())\n\n    orography = EarthOrography(spectral_grid, scale=parameters.orography_scale)\n\n    # construct model\n    model = PrimitiveWetModel(spectral_grid; ocean, land, initial_conditions, orography)\n\n    # Add rain gauge, locate in Pittsburgh PA\n    rain_gauge = RainGauge(spectral_grid, lond=-80, latd=40.45)\n    add!(model, rain_gauge)\n\n    # Initialize\n    simulation = initialize!(model, time=DateTime(2025, 7, 22))\n\n    # Add additional  mountain\n    H = parameters.mountain_height\n    λ₀, φ₀, σ = parameters.mountain_lon, parameters.mountain_lat, parameters.mountain_size  \n    set!(model, orography=(λ,φ) -> H*exp(-spherical_distance((λ,φ), (λ₀,φ₀), radius=360/2π)^2/2σ^2), add=true)\n\n    # land sea surface temperature anomalies\n    # 1. USA\n    set!(simulation, soil_temperature=\n        (λ, φ, k) -> (30 < φ < 50) && (240 < λ < 285) ? parameters.temperature_usa : 0, add=true)\n\n    # 2. Pennsylvania\n    A = parameters.temperature_pa\n    λ_az, φ_az, σ_az = -80, 40.45, 4    # location [˚], size [˚] of Azores\n    set!(simulation, soil_temperature=\n        (λ, φ, k) -> A*exp(-spherical_distance((λ,φ), (λ_az,φ_az), radius=360/2π)^2/2σ_az^2), add=true)\n\n    # Run simulation for 20 days\n    run!(simulation, period=Day(20))\n\n    # skip first 5 days, as is done in the RainMaker challenge\n    RainMaker.skip!(rain_gauge, Day(5))\n\n    # evaluate rain gauge\n    lsc = rain_gauge.accumulated_rain_large_scale\n    conv = rain_gauge.accumulated_rain_convection\n    total_precip = maximum(lsc) + maximum(conv)\n    return rain_gauge, total_precip\nend\n\nfinal_params = \n[2.0163488388061523,\n 5013.733625411987,\n -0.017316662706434727,\n -22.202972173690796,\n -19.587678909301758,\n 282.97233670949936,\n 300.200936794281,\n 2.133525013923645,\n 4.704113602638245,\n 34.923005402088165]\n\nrain_gauge, total_precip = max_precipitation(final_params)\n\ntotal_precip  # produces 212.7933 on RainMakerChallenge2025.jl's evaluator, 211.040 on this evaluator -- TODO investigate the discrepancy\n\nRainMaker.plot(rain_gauge, skip=Day(5)) # hide\nsave(\"submission_gabrielks_brute_force_1.png\", ans) # hide\nnothing # hide","category":"page"},{"location":"submissions/","page":"List of submissions","title":"List of submissions","text":"(Image: submission: gabrielks_brute_force_1)","category":"page"},{"location":"submissions/#Theo-D:-Kriging-Surrogate-with-Latin-Hypercube-Sampling","page":"List of submissions","title":"Theo D: Kriging Surrogate with Latin Hypercube Sampling","text":"","category":"section"},{"location":"submissions/","page":"List of submissions","title":"List of submissions","text":"path: /submissions/theo_juliacon.jl","category":"page"},{"location":"submissions/","page":"List of submissions","title":"List of submissions","text":"rank: 7. of 14 submissions","category":"page"},{"location":"submissions/","page":"List of submissions","title":"List of submissions","text":"using CairoMakie # hide\nauthor = \"Theo D\"\ndescription = \"Kriging Surrogate with Latin Hypercube Sampling\"\n\n#=\nusing JLSO\nusing EvoTrees\nusing OptimizationBBO, Optimization\n\npath = joinpath(dirname(@__DIR__), \"data\", \"10kdata.jlso\")\ndata = JLSO.load(path)\n\nx = data[:d].inputs\ny = data[:d].outputs\n\nX_train = x'\ny_train = vec(y)\n\nconfig = EvoTreeRegressor(\n    nrounds=200,\n    max_depth=4,\n    eta=0.1,\n    rng=123\n)\n\nprintln(\"Training EvoTrees model...\")\nmodel = EvoTrees.fit_evotree(config; x_train=X_train, y_train=y_train)\nprintln(\"Model trained successfully\")\n\nfunction surrogate_model(params)\n    pred = EvoTrees.predict(model, reshape(params, 1, :))\n    return Float64(pred[1])\nend\n\nfunction objective(params, p)\n    return -surrogate_model(params)\nend\n\nlower_bounds = [0., -2000., 0., -180., -90., 270., 270., -5., -5., 5.]\nupper_bounds = [2., 5000., 30., 180., 90., 300., 300., 5., 5., 50.]\n\noptf = OptimizationFunction(objective)\nprob = Optimization.OptimizationProblem(optf, [1, 0, 1, -80, 40.45, 300, 273, 0, 0, 35], \n                          lb=lower_bounds, ub=upper_bounds)\n\nprintln(\"Starting optimization...\")\nsol = solve(prob, BBO_adaptive_de_rand_1_bin_radiuslimited(); maxtime=60)\n\nprintln(\"Optimized parameters: \", sol.u)\nprintln(\"Predicted max precipitation from surrogate: \", surrogate_model(sol.u))\n=#\n\nusing SpeedyWeather, RainMaker\n\n\nconst PARAMETER_KEYS = (\n    :orography_scale,           # [1],      default: 1, scale of global orography\n    :mountain_height,           # [m],      default: 0, height of an additional azores mountain\n    :mountain_size,             # [˚],      default: 1, horizontal size of mountain in Pittsburgh\n    :mountain_lon,              # [˚E],     default: -80, longitude of that mountain in Pittsburgh\n    :mountain_lat,              # [˚N],     default: 40.45, latitude of that mountain in Pittsburgh\n    :temperature_equator,       # [K],      default: 300, sea surface temperature at the equator\n    :temperature_pole,          # [K],      default: 273, sea surfaec temperature at the poles\n    :temperature_usa,           # [K],      default: 0, land surface temperature anomaly over the USA\n    :temperature_pa,            # [K],      default: 0, land surface temperature anomaly in Pennsylvania\n    :zonal_wind,                # [m/s],    default: 35, zonal wind speed\n)\n\nconst PARAMETER_DEFAULTS = [1, 0, 1, -80, 40.45, 300, 273, 0, 0, 35]\n\nfunction max_precipitation(parameters::AbstractVector)\n    parameter_tuple = NamedTuple{PARAMETER_KEYS}(parameters)\n    return max_precipitation(parameter_tuple)\nend\n\nfunction max_precipitation(parameters::NamedTuple)\n\n    # define resolution. Use trunc=42, 63, 85, 127, ... for higher resolution, cubically slower\n    spectral_grid = SpectralGrid(trunc=31, nlayers=8)\n\n    # Define AquaPlanet ocean, for idealised sea surface temperatures\n    # but don't change land-sea mask = retain real ocean basins\n    ocean = AquaPlanet(spectral_grid,\n                temp_equator=parameters.temperature_equator,\n                temp_poles=parameters.temperature_pole)\n\n    land_temperature = ConstantLandTemperature(spectral_grid)\n    land = LandModel(spectral_grid; temperature=land_temperature)\n\n    initial_conditions = InitialConditions(\n        vordiv = ZonalWind(u₀=parameters.zonal_wind),\n        temp = JablonowskiTemperature(u₀=parameters.zonal_wind),\n        pres = PressureOnOrography(),\n        humid = ConstantRelativeHumidity())\n\n    orography = EarthOrography(spectral_grid, scale=parameters.orography_scale)\n\n    # construct model\n    model = PrimitiveWetModel(spectral_grid; ocean, land, initial_conditions, orography)\n\n    # Add rain gauge, locate in Pittsburgh PA\n    rain_gauge = RainGauge(spectral_grid, lond=-80, latd=40.45)\n    add!(model, rain_gauge)\n\n    # Initialize\n    simulation = initialize!(model, time=DateTime(2025, 7, 22))\n\n    # Add additional  mountain\n    H = parameters.mountain_height\n    λ₀, φ₀, σ = parameters.mountain_lon, parameters.mountain_lat, parameters.mountain_size  \n    set!(model, orography=(λ,φ) -> H*exp(-spherical_distance((λ,φ), (λ₀,φ₀), radius=360/2π)^2/2σ^2), add=true)\n\n    # land sea surface temperature anomalies\n    # 1. USA\n    set!(simulation, soil_temperature=\n        (λ, φ, k) -> (30 < φ < 50) && (240 < λ < 285) ? parameters.temperature_usa : 0, add=true)\n\n    # 2. Pennsylvania\n    A = parameters.temperature_pa\n    λ_az, φ_az, σ_az = -80, 40.45, 4    # location [˚], size [˚] of Azores\n    set!(simulation, soil_temperature=\n        (λ, φ, k) -> A*exp(-spherical_distance((λ,φ), (λ_az,φ_az), radius=360/2π)^2/2σ_az^2), add=true)\n\n    # Run simulation for 20 days\n    run!(simulation, period=Day(20))\n\n    # skip first 5 days, as is done in the RainMaker challenge\n    RainMaker.skip!(rain_gauge, Day(5))\n\n    # evaluate rain gauge\n    lsc = rain_gauge.accumulated_rain_large_scale\n    conv = rain_gauge.accumulated_rain_convection\n    total_precip = maximum(lsc) + maximum(conv)\n    return rain_gauge, total_precip\nend\n\nfinal_params = [1.9728003644919363, 2506.981756969998, 10.799751688314835, -119.61854020127022, 55.932955161047225, 287.9571828050346, 291.00468964730595, 0.5460025649020176, 4.157291328686813, 25.87763330165432]\n\nrain_gauge, total_precip = max_precipitation(final_params)\n\ntotal_precip\n\nRainMaker.plot(rain_gauge, skip=Day(5)) # hide\nsave(\"submission_theo_juliacon.png\", ans) # hide\nnothing # hide","category":"page"},{"location":"submissions/","page":"List of submissions","title":"List of submissions","text":"(Image: submission: theo_juliacon)","category":"page"},{"location":"submissions/#Cameron-Bieganek:-Latin-hypercube-search,-no-surrogate.","page":"List of submissions","title":"Cameron Bieganek: Latin hypercube search, no surrogate.","text":"","category":"section"},{"location":"submissions/","page":"List of submissions","title":"List of submissions","text":"path: /submissions/bieganek_latin_hypercube.jl","category":"page"},{"location":"submissions/","page":"List of submissions","title":"List of submissions","text":"rank: 8. of 14 submissions","category":"page"},{"location":"submissions/","page":"List of submissions","title":"List of submissions","text":"using CairoMakie # hide\n\n\nauthor = \"Cameron Bieganek\"\ndescription = \"Latin hypercube search, no surrogate.\"\n\n#=\nusing RainMakerChallenge2025\nusing Surrogates\n\nlb = [0., -2000., 0., -180., -90., 270., 270., -5., -5., 5.]\nub = [2., 5000., 30., 180., 90., 300., 300., 5., 5., 50.]\nn = 800\n\nparams = collect.(sample(n, lb, ub, LatinHypercubeSample()))\n\nrainfall = max_precipitation.(params)\n\nmaximum(rainfall)\ni = argmax(rainfall)\nbest_params = params[i]\n=#\n\nusing SpeedyWeather, RainMaker\n\n\nconst PARAMETER_KEYS = (\n    :orography_scale,           # [1],      default: 1, scale of global orography\n    :mountain_height,           # [m],      default: 0, height of an additional azores mountain\n    :mountain_size,             # [˚],      default: 1, horizontal size of mountain in Pittsburgh\n    :mountain_lon,              # [˚E],     default: -80, longitude of that mountain in Pittsburgh\n    :mountain_lat,              # [˚N],     default: 40.45, latitude of that mountain in Pittsburgh\n    :temperature_equator,       # [K],      default: 300, sea surface temperature at the equator\n    :temperature_pole,          # [K],      default: 273, sea surfaec temperature at the poles\n    :temperature_usa,           # [K],      default: 0, land surface temperature anomaly over the USA\n    :temperature_pa,            # [K],      default: 0, land surface temperature anomaly in Pennsylvania\n    :zonal_wind,                # [m/s],    default: 35, zonal wind speed\n)\n\nconst PARAMETER_DEFAULTS = [1, 0, 1, -80, 40.45, 300, 273, 0, 0, 35]\n\nfunction max_precipitation(parameters::AbstractVector)\n    parameter_tuple = NamedTuple{PARAMETER_KEYS}(parameters)\n    return max_precipitation(parameter_tuple)\nend\n\nfunction max_precipitation(parameters::NamedTuple)\n\n    # define resolution. Use trunc=42, 63, 85, 127, ... for higher resolution, cubically slower\n    spectral_grid = SpectralGrid(trunc=31, nlayers=8)\n\n    # Define AquaPlanet ocean, for idealised sea surface temperatures\n    # but don't change land-sea mask = retain real ocean basins\n    ocean = AquaPlanet(spectral_grid,\n                temp_equator=parameters.temperature_equator,\n                temp_poles=parameters.temperature_pole)\n\n    land_temperature = ConstantLandTemperature(spectral_grid)\n    land = LandModel(spectral_grid; temperature=land_temperature)\n\n    initial_conditions = InitialConditions(\n        vordiv = ZonalWind(u₀=parameters.zonal_wind),\n        temp = JablonowskiTemperature(u₀=parameters.zonal_wind),\n        pres = PressureOnOrography(),\n        humid = ConstantRelativeHumidity())\n\n    orography = EarthOrography(spectral_grid, scale=parameters.orography_scale)\n\n    # construct model\n    model = PrimitiveWetModel(spectral_grid; ocean, land, initial_conditions, orography)\n\n    # Add rain gauge, locate in Pittsburgh PA\n    rain_gauge = RainGauge(spectral_grid, lond=-80, latd=40.45)\n    add!(model, rain_gauge)\n\n    # Initialize\n    simulation = initialize!(model, time=DateTime(2025, 7, 22))\n\n    # Add additional  mountain\n    H = parameters.mountain_height\n    λ₀, φ₀, σ = parameters.mountain_lon, parameters.mountain_lat, parameters.mountain_size  \n    set!(model, orography=(λ,φ) -> H*exp(-spherical_distance((λ,φ), (λ₀,φ₀), radius=360/2π)^2/2σ^2), add=true)\n\n    # land sea surface temperature anomalies\n    # 1. USA\n    set!(simulation, soil_temperature=\n        (λ, φ, k) -> (30 < φ < 50) && (240 < λ < 285) ? parameters.temperature_usa : 0, add=true)\n\n    # 2. Pennsylvania\n    A = parameters.temperature_pa\n    λ_az, φ_az, σ_az = -80, 40.45, 4    # location [˚], size [˚] of Azores\n    set!(simulation, soil_temperature=\n        (λ, φ, k) -> A*exp(-spherical_distance((λ,φ), (λ_az,φ_az), radius=360/2π)^2/2σ_az^2), add=true)\n\n    # Run simulation for 20 days\n    run!(simulation, period=Day(20))\n\n    # skip first 5 days, as is done in the RainMaker challenge\n    RainMaker.skip!(rain_gauge, Day(5))\n\n    # evaluate rain gauge\n    lsc = rain_gauge.accumulated_rain_large_scale\n    conv = rain_gauge.accumulated_rain_convection\n    total_precip = maximum(lsc) + maximum(conv)\n    return rain_gauge, total_precip\nend\n\nfinal_params = [\n    1.85625,\n    2230.625,\n    3.0937500000000004,\n    -76.72500000000001,\n    6.187500000000014,\n    290.34375,\n    298.33125,\n    -3.46875,\n    2.6312500000000005,\n    32.534375,\n]\n\nrain_gauge, total_precip = max_precipitation(final_params)\n\ntotal_precip\n\nRainMaker.plot(rain_gauge, skip=Day(5)) # hide\nsave(\"submission_bieganek_latin_hypercube.png\", ans) # hide\nnothing # hide","category":"page"},{"location":"submissions/","page":"List of submissions","title":"List of submissions","text":"(Image: submission: bieganek_latin_hypercube)","category":"page"},{"location":"submissions/#Chris-Rackauckas:-Evotrees.jl-Surrogate,-Claude-generated","page":"List of submissions","title":"Chris Rackauckas: Evotrees.jl Surrogate, Claude generated","text":"","category":"section"},{"location":"submissions/","page":"List of submissions","title":"List of submissions","text":"path: /submissions/chris_evotrees.jl","category":"page"},{"location":"submissions/","page":"List of submissions","title":"List of submissions","text":"rank: 9. of 14 submissions","category":"page"},{"location":"submissions/","page":"List of submissions","title":"List of submissions","text":"using CairoMakie # hide\nauthor = \"Chris Rackauckas\"\ndescription = \"Evotrees.jl Surrogate, Claude generated\"\n\n#=\nusing JLSO\nusing EvoTrees\nusing OptimizationBBO, Optimization\n\npath = joinpath(dirname(@__DIR__), \"data\", \"10kdata.jlso\")\ndata = JLSO.load(path)\n\nx = data[:d].inputs\ny = data[:d].outputs\n\nX_train = x'\ny_train = vec(y)\n\nconfig = EvoTreeRegressor(\n    nrounds=200,\n    max_depth=4,\n    eta=0.1,\n    rng=123\n)\n\nprintln(\"Training EvoTrees model...\")\nmodel = EvoTrees.fit_evotree(config; x_train=X_train, y_train=y_train)\nprintln(\"Model trained successfully\")\n\nfunction surrogate_model(params)\n    pred = EvoTrees.predict(model, reshape(params, 1, :))\n    return Float64(pred[1])\nend\n\nfunction objective(params, p)\n    return -surrogate_model(params)\nend\n\nlower_bounds = [0., -2000., 0., -180., -90., 270., 270., -5., -5., 5.]\nupper_bounds = [2., 5000., 30., 180., 90., 300., 300., 5., 5., 50.]\n\noptf = OptimizationFunction(objective)\nprob = Optimization.OptimizationProblem(optf, [1, 0, 1, -80, 40.45, 300, 273, 0, 0, 35], \n                          lb=lower_bounds, ub=upper_bounds)\n\nprintln(\"Starting optimization...\")\nsol = solve(prob, BBO_adaptive_de_rand_1_bin_radiuslimited(); maxtime=60)\n\nprintln(\"Optimized parameters: \", sol.u)\nprintln(\"Predicted max precipitation from surrogate: \", surrogate_model(sol.u))\n=#\n\nusing SpeedyWeather, RainMaker\n\n\nconst PARAMETER_KEYS = (\n    :orography_scale,           # [1],      default: 1, scale of global orography\n    :mountain_height,           # [m],      default: 0, height of an additional azores mountain\n    :mountain_size,             # [˚],      default: 1, horizontal size of mountain in Pittsburgh\n    :mountain_lon,              # [˚E],     default: -80, longitude of that mountain in Pittsburgh\n    :mountain_lat,              # [˚N],     default: 40.45, latitude of that mountain in Pittsburgh\n    :temperature_equator,       # [K],      default: 300, sea surface temperature at the equator\n    :temperature_pole,          # [K],      default: 273, sea surfaec temperature at the poles\n    :temperature_usa,           # [K],      default: 0, land surface temperature anomaly over the USA\n    :temperature_pa,            # [K],      default: 0, land surface temperature anomaly in Pennsylvania\n    :zonal_wind,                # [m/s],    default: 35, zonal wind speed\n)\n\nconst PARAMETER_DEFAULTS = [1, 0, 1, -80, 40.45, 300, 273, 0, 0, 35]\n\nfunction max_precipitation(parameters::AbstractVector)\n    parameter_tuple = NamedTuple{PARAMETER_KEYS}(parameters)\n    return max_precipitation(parameter_tuple)\nend\n\nfunction max_precipitation(parameters::NamedTuple)\n\n    # define resolution. Use trunc=42, 63, 85, 127, ... for higher resolution, cubically slower\n    spectral_grid = SpectralGrid(trunc=31, nlayers=8)\n\n    # Define AquaPlanet ocean, for idealised sea surface temperatures\n    # but don't change land-sea mask = retain real ocean basins\n    ocean = AquaPlanet(spectral_grid,\n                temp_equator=parameters.temperature_equator,\n                temp_poles=parameters.temperature_pole)\n\n    land_temperature = ConstantLandTemperature(spectral_grid)\n    land = LandModel(spectral_grid; temperature=land_temperature)\n\n    initial_conditions = InitialConditions(\n        vordiv = ZonalWind(u₀=parameters.zonal_wind),\n        temp = JablonowskiTemperature(u₀=parameters.zonal_wind),\n        pres = PressureOnOrography(),\n        humid = ConstantRelativeHumidity())\n\n    orography = EarthOrography(spectral_grid, scale=parameters.orography_scale)\n\n    # construct model\n    model = PrimitiveWetModel(spectral_grid; ocean, land, initial_conditions, orography)\n\n    # Add rain gauge, locate in Pittsburgh PA\n    rain_gauge = RainGauge(spectral_grid, lond=-80, latd=40.45)\n    add!(model, rain_gauge)\n\n    # Initialize\n    simulation = initialize!(model, time=DateTime(2025, 7, 22))\n\n    # Add additional  mountain\n    H = parameters.mountain_height\n    λ₀, φ₀, σ = parameters.mountain_lon, parameters.mountain_lat, parameters.mountain_size  \n    set!(model, orography=(λ,φ) -> H*exp(-spherical_distance((λ,φ), (λ₀,φ₀), radius=360/2π)^2/2σ^2), add=true)\n\n    # land sea surface temperature anomalies\n    # 1. USA\n    set!(simulation, soil_temperature=\n        (λ, φ, k) -> (30 < φ < 50) && (240 < λ < 285) ? parameters.temperature_usa : 0, add=true)\n\n    # 2. Pennsylvania\n    A = parameters.temperature_pa\n    λ_az, φ_az, σ_az = -80, 40.45, 4    # location [˚], size [˚] of Azores\n    set!(simulation, soil_temperature=\n        (λ, φ, k) -> A*exp(-spherical_distance((λ,φ), (λ_az,φ_az), radius=360/2π)^2/2σ_az^2), add=true)\n\n    # Run simulation for 20 days\n    run!(simulation, period=Day(20))\n\n    # skip first 5 days, as is done in the RainMaker challenge\n    RainMaker.skip!(rain_gauge, Day(5))\n\n    # evaluate rain gauge\n    lsc = rain_gauge.accumulated_rain_large_scale\n    conv = rain_gauge.accumulated_rain_convection\n    total_precip = maximum(lsc) + maximum(conv)\n    return rain_gauge, total_precip\nend\n\nfinal_params = [1.99, -1494.66, 0.44, -175.36, -84.63, 274.32, 277.01, 4.70,\n  4.96, 27.44]\n\nrain_gauge, total_precip = max_precipitation(final_params)\n\ntotal_precip\n\nRainMaker.plot(rain_gauge, skip=Day(5)) # hide\nsave(\"submission_chris_evotrees.png\", ans) # hide\nnothing # hide","category":"page"},{"location":"submissions/","page":"List of submissions","title":"List of submissions","text":"(Image: submission: chris_evotrees)","category":"page"},{"location":"submissions/#Shirin-Ermis:-Aqua-planet-simulation-with-a-mountain","page":"List of submissions","title":"Shirin Ermis: Aqua-planet simulation with a mountain","text":"","category":"section"},{"location":"submissions/","page":"List of submissions","title":"List of submissions","text":"path: /submissions/aquaplanet_mountain.jl","category":"page"},{"location":"submissions/","page":"List of submissions","title":"List of submissions","text":"rank: 10. of 14 submissions","category":"page"},{"location":"submissions/","page":"List of submissions","title":"List of submissions","text":"using CairoMakie # hide\nauthor = \"Shirin Ermis\"\ndescription = \"Aqua-planet simulation with a mountain\"\n\nusing SpeedyWeather, RainMaker\n\nspectral_grid = SpectralGrid(trunc=31, nlayers=10)\nmodel = PrimitiveWetModel(spectral_grid)\n\n# Set up aqauaplanet but add large mountain in \"North Sea\" after initialization!\nocean = AquaPlanet(spectral_grid, temp_equator=302, temp_poles=300)\nland_sea_mask = AquaPlanetMask(spectral_grid)\nmodel = PrimitiveWetModel(spectral_grid; ocean, land_sea_mask)\n\n# Add rain gauge\nrain_gauge = RainGauge(spectral_grid, lond=-80, latd=40.45)\nadd!(model, rain_gauge)\n\n# Initialize and run simulation\nsimulation = initialize!(model, time=DateTime(2000, 9, 1))\n\n# Add mountain now! details for mountain\nH, λ₀, φ₀, σ = 4000, 2, 51, 5     # height, lon, lat position, and width\nset!(model, orography=(λ,φ) -> H*exp(-spherical_distance((λ,φ), (λ₀,φ₀), radius=360/2π)^2/2σ^2))\n\n# Run simulation for 20 days\nrun!(simulation, period=Day(20))\n\n# Plot the results (not needed for submission but doesn't hurt!)\nusing CairoMakie\n# heatmap(model.orography.orography, title=\"My orogoraphy [m]\") # check orography\nRainMaker.plot(rain_gauge, rate_Δt=Hour(1))\n\nRainMaker.plot(rain_gauge, skip=Day(5)) # hide\nsave(\"submission_aquaplanet_mountain.png\", ans) # hide\nnothing # hide","category":"page"},{"location":"submissions/","page":"List of submissions","title":"List of submissions","text":"(Image: submission: aquaplanet_mountain)","category":"page"},{"location":"submissions/#Milan:-Aquaplanet","page":"List of submissions","title":"Milan: Aquaplanet","text":"","category":"section"},{"location":"submissions/","page":"List of submissions","title":"List of submissions","text":"path: /submissions/aquaplanet.jl","category":"page"},{"location":"submissions/","page":"List of submissions","title":"List of submissions","text":"rank: 11. of 14 submissions","category":"page"},{"location":"submissions/","page":"List of submissions","title":"List of submissions","text":"using CairoMakie # hide\nauthor = \"Milan\"\ndescription = \"Aquaplanet\"\n\nusing SpeedyWeather, RainMaker\n\nspectral_grid = SpectralGrid(trunc=31, nlayers=8)\n\n# define aquaplanet\nocean = AquaPlanet(spectral_grid, temp_equator=302, temp_poles=273)\nland_sea_mask = AquaPlanetMask(spectral_grid)\norography = NoOrography(spectral_grid)\nmodel = PrimitiveWetModel(spectral_grid; ocean, land_sea_mask, orography)\n\nrain_gauge = RainGauge(spectral_grid, lond=-80, latd=40.45)\nadd!(model, rain_gauge)\n\nsimulation = initialize!(model)\nrun!(simulation, period=Day(20))\nRainMaker.plot(rain_gauge, skip=Day(5)) # hide\nsave(\"submission_aquaplanet.png\", ans) # hide\nnothing # hide","category":"page"},{"location":"submissions/","page":"List of submissions","title":"List of submissions","text":"(Image: submission: aquaplanet)","category":"page"},{"location":"submissions/#Tim-Reichelt:-North-Sea-mountain","page":"List of submissions","title":"Tim Reichelt: North Sea mountain","text":"","category":"section"},{"location":"submissions/","page":"List of submissions","title":"List of submissions","text":"path: /submissions/north_sea_mountain.jl","category":"page"},{"location":"submissions/","page":"List of submissions","title":"List of submissions","text":"rank: 12. of 14 submissions","category":"page"},{"location":"submissions/","page":"List of submissions","title":"List of submissions","text":"using CairoMakie # hide\nauthor = \"Tim Reichelt\"\ndescription = \"North Sea mountain\"\n\nusing SpeedyWeather, RainMaker\n\nspectral_grid = SpectralGrid(trunc=31, nlayers=8)\nmodel = PrimitiveWetModel(spectral_grid)\n\nrain_gauge = RainGauge(spectral_grid, lond=-80, latd=40.45)\nadd!(model, rain_gauge)\n\nsimulation = initialize!(model)\n\n# add a massive mountain at 51.75°N, 0°W, *after* model initialization\n# using spherical_distance for geodesic distances, use radius=360/2π for distance in degrees\nH, λ₀, φ₀, σ = 4000, 2, 51, 5     # height, lon, lat position, and width\nset!(model, orography=(λ,φ) -> H*exp(-spherical_distance((λ,φ), (λ₀,φ₀), radius=360/2π)^2/2σ^2))\n\nrun!(simulation, period=Day(20))\nRainMaker.plot(rain_gauge, skip=Day(5)) # hide\nsave(\"submission_north_sea_mountain.png\", ans) # hide\nnothing # hide","category":"page"},{"location":"submissions/","page":"List of submissions","title":"List of submissions","text":"(Image: submission: north_sea_mountain)","category":"page"},{"location":"submissions/#Milan:-default","page":"List of submissions","title":"Milan: default","text":"","category":"section"},{"location":"submissions/","page":"List of submissions","title":"List of submissions","text":"path: /submissions/default.jl","category":"page"},{"location":"submissions/","page":"List of submissions","title":"List of submissions","text":"rank: 13. of 14 submissions","category":"page"},{"location":"submissions/","page":"List of submissions","title":"List of submissions","text":"using CairoMakie # hide\nauthor = \"Milan\"\ndescription = \"default\"\n\nusing SpeedyWeather, RainMaker\n\nspectral_grid = SpectralGrid(trunc=31, nlayers=8)\nmodel = PrimitiveWetModel(spectral_grid)\n\nrain_gauge = RainGauge(spectral_grid, lond=-80, latd=40.45)\nadd!(model, rain_gauge)\n\nsimulation = initialize!(model)\nrun!(simulation, period=Day(20))\nRainMaker.plot(rain_gauge, skip=Day(5)) # hide\nsave(\"submission_default.png\", ans) # hide\nnothing # hide","category":"page"},{"location":"submissions/","page":"List of submissions","title":"List of submissions","text":"(Image: submission: default)","category":"page"},{"location":"submissions/#Milan:-Atlantic-mountain","page":"List of submissions","title":"Milan: Atlantic mountain","text":"","category":"section"},{"location":"submissions/","page":"List of submissions","title":"List of submissions","text":"path: /submissions/atlantic_mountain.jl","category":"page"},{"location":"submissions/","page":"List of submissions","title":"List of submissions","text":"rank: 14. of 14 submissions","category":"page"},{"location":"submissions/","page":"List of submissions","title":"List of submissions","text":"using CairoMakie # hide\nauthor = \"Milan\"\ndescription = \"Atlantic mountain\"\n\nusing SpeedyWeather, RainMaker\n\nspectral_grid = SpectralGrid(trunc=31, nlayers=8)\nmodel = PrimitiveWetModel(spectral_grid)\n\nrain_gauge = RainGauge(spectral_grid, lond=-80, latd=40.45)\nadd!(model, rain_gauge)\n\nsimulation = initialize!(model)\n\n# add a massive mountain at 50°N, 35°W, *after* model initialization\nH, λ₀, φ₀, σ = 4000, 325, 50, 5     # height, lon, lat position, and width\nset!(model, orography=(λ,φ) -> H*exp((-(λ-λ₀)^2 - (φ-φ₀)^2)/2σ^2), add=true)\n\nrun!(simulation, period=Day(20))\nRainMaker.plot(rain_gauge, skip=Day(5)) # hide\nsave(\"submission_atlantic_mountain.png\", ans) # hide\nnothing # hide","category":"page"},{"location":"submissions/","page":"List of submissions","title":"List of submissions","text":"(Image: submission: atlantic_mountain)","category":"page"},{"location":"instructions/#RainMaker-instructions","page":"Instructions","title":"RainMaker instructions","text":"","category":"section"},{"location":"instructions/","page":"Instructions","title":"Instructions","text":"While the List of submissions gives you some idea of what you can do make it rain more or less in a SpeedyWeather simulation, the following provides more instructions and serves as an introduction to atmospheric modelling with SpeedyWeather.","category":"page"},{"location":"instructions/","page":"Instructions","title":"Instructions","text":"You can analyse precipitation as a time series (Visualising RainGauge measurements) or as a global map accumulated during the simulation (Visualising accumulated rainfall globally).","category":"page"},{"location":"instructions/#General-workflow-to-run-SpeedyWeather","page":"Instructions","title":"General workflow to run SpeedyWeather","text":"","category":"section"},{"location":"instructions/","page":"Instructions","title":"Instructions","text":"There's more information in the SpeedyWeather documentation but in short there are 4 steps","category":"page"},{"location":"instructions/","page":"Instructions","title":"Instructions","text":"using SpeedyWeather\n\n# 1. define the resolution\nspectral_grid = SpectralGrid(trunc=31, nlayers=8)\n\n# 2. create a model\nmodel = PrimitiveWetModel(spectral_grid)\n\n# 3. initialize the model\nsimulation = initialize!(model)\n\n# 4. run the model\nrun!(simulation, period=Day(10))","category":"page"},{"location":"instructions/","page":"Instructions","title":"Instructions","text":"You can add a RainGauge to measure precipitation, but the following will focus on ways you can change the model, impacting what's been simulated. They may or may not have a large impact on the simulated precipitation but that is up to you to figure out.","category":"page"},{"location":"instructions/#Change-the-resolution","page":"Instructions","title":"Change the resolution","text":"","category":"section"},{"location":"instructions/","page":"Instructions","title":"Instructions","text":"SpeedyWeather is a spectral model. That means it internally represents its variables as coefficients of horizontal waves on the sphere (the spherical harmonics) up to a certain maximum wavenumber that is usually referred to as truncation. So for a truncation of 31, SpeedyWeather would resolve wavenumbers 0 to 31, but not 32 and larger. The higher the truncation the higher the resolution  and automatically chosen higher resolution of the grid. You control the resolution through the keyword argument trunc of the SpectralGrid object that defines the resolution of a simulation","category":"page"},{"location":"instructions/","page":"Instructions","title":"Instructions","text":"using SpeedyWeather\nspectral_grid =  SpectralGrid(trunc=42)","category":"page"},{"location":"instructions/","page":"Instructions","title":"Instructions","text":"Now change trunc (e.g. 31, 42, 63, 85, 127) and check what happens to precipitation when you run a simulation at that resolution. You can also change the number of vertical layers with the keyword argument nlayers, e.g.","category":"page"},{"location":"instructions/","page":"Instructions","title":"Instructions","text":"spectral_grid =  SpectralGrid(trunc=31, nlayers=5)","category":"page"},{"location":"instructions/","page":"Instructions","title":"Instructions","text":"Note however, that too many vertical layers can make the model unstable because of the (simpler) vertical advection that is used. This is not the place to elaborate on that, but just to warn you that nlayers=100 is unlikely to \"just work\". Try to find out more generally, with changing trunc and nlayers","category":"page"},{"location":"instructions/","page":"Instructions","title":"Instructions","text":"How does the grid spacing change?\nHow does the speed of the simulation change?","category":"page"},{"location":"instructions/","page":"Instructions","title":"Instructions","text":"Bonus question","category":"page"},{"location":"instructions/","page":"Instructions","title":"Instructions","text":"Why 31, 42, 63, ... as given above? For more details see Available horizontal resolutions and Matching spectral and grid resolution\nHow are the vertical layers spaced? Check spectral_grid.vertical_coordinates and read on Sigma coordinates","category":"page"},{"location":"instructions/#Change-the-grid","page":"Instructions","title":"Change the grid","text":"","category":"section"},{"location":"instructions/","page":"Instructions","title":"Instructions","text":"While SpeedyWeather is a spectral model not all computations are done in spectral space, many are still done in grid space. That's why people often call this method also pseudo-spectral. You can control the grid through the argument Grid","category":"page"},{"location":"instructions/","page":"Instructions","title":"Instructions","text":"spectral_grid =  SpectralGrid(trunc=31, Grid=FullGaussianGrid)","category":"page"},{"location":"instructions/","page":"Instructions","title":"Instructions","text":"Try FullGaussianGrid, FullClenshawGrid, OctahedralGaussianGrid, or HEALPixGrid among others. Do they have any impact on the simulated precipitation? More generally","category":"page"},{"location":"instructions/","page":"Instructions","title":"Instructions","text":"Which grids have more, which fewer (horizontal) grid points at a given trunc?\nOn each grid, are the grid cells globally of similar size or not?\nVisualise the grids!","category":"page"},{"location":"instructions/","page":"Instructions","title":"Instructions","text":"Bonus question","category":"page"},{"location":"instructions/","page":"Instructions","title":"Instructions","text":"A higher/lower dealiasing increases/decreases the grid resolution without changes the spectral resolution. Why would one do that?","category":"page"},{"location":"instructions/#Change-the-time-step","page":"Instructions","title":"Change the time step","text":"","category":"section"},{"location":"instructions/","page":"Instructions","title":"Instructions","text":"The time step of SpeedyWeather is controlled through the time stepping method of the model. This model component needs to know the spatial resolution to pick a time step by default that is stable, but you can still control this. SpeedyWeather's time integration is based on the Leapfrog scheme, so you create such a component like this","category":"page"},{"location":"instructions/","page":"Instructions","title":"Instructions","text":"time_stepping = Leapfrog(spectral_grid, Δt_at_T31=Minute(20))","category":"page"},{"location":"instructions/","page":"Instructions","title":"Instructions","text":"where the argument Δt_at_T31 determines the timestep Δt (write \\Delta then hit tab) relative to a truncation of 31 (called T31), the actual time step is then in Δt_sec, scaled linearly from T31 to whatever resolution you chose. You can provide any Second, Minute, Hour (but note that there is a stability limit above which your simulation quickly blows up). But do not forget to also pass this component to the model constructor, i.e.","category":"page"},{"location":"instructions/","page":"Instructions","title":"Instructions","text":"model = PrimitiveWetModel(spectral_grid; time_stepping)\nnothing # hide","category":"page"},{"location":"instructions/","page":"Instructions","title":"Instructions","text":"where ; time_stepping matches a keyword argument time_stepping with the variable of the same name. This is equivalent to , time_stepping=time_stepping.","category":"page"},{"location":"instructions/","page":"Instructions","title":"Instructions","text":"How large a time step can you choose for a T31 resolution?\nHow does the speed or simulation time change with a changed time step?","category":"page"},{"location":"instructions/","page":"Instructions","title":"Instructions","text":"Bonus question","category":"page"},{"location":"instructions/","page":"Instructions","title":"Instructions","text":"How do you choose a sensible time step?","category":"page"},{"location":"instructions/#Change-the-season","page":"Instructions","title":"Change the season","text":"","category":"section"},{"location":"instructions/","page":"Instructions","title":"Instructions","text":"Some boundary conditions of SpeedyWeather depend by default on the time of the year, these are","category":"page"},{"location":"instructions/","page":"Instructions","title":"Instructions","text":"sea and land surface temperatures\nsoil moisture","category":"page"},{"location":"instructions/","page":"Instructions","title":"Instructions","text":"changing the start time of your simulation therefore will have an impact on precipitation. At the moment no boundary conditions change with the year. You can change this start time when the model is initialized, i.e.","category":"page"},{"location":"instructions/","page":"Instructions","title":"Instructions","text":"simulation = initialize!(model, time=DateTime(2000, 8, 1))\nsimulation.prognostic_variables.clock","category":"page"},{"location":"instructions/","page":"Instructions","title":"Instructions","text":"With the last line you can inspect the clock object that keeps track of time.","category":"page"},{"location":"instructions/","page":"Instructions","title":"Instructions","text":"Why would precipitation be higher or lower in different seasons?","category":"page"},{"location":"instructions/#Change-the-orography","page":"Instructions","title":"Change the orography","text":"","category":"section"},{"location":"instructions/","page":"Instructions","title":"Instructions","text":"You can change the orography in several different ways, the most convenient is probably using the set! function with anonymous functions (λ,φ) -> ... of longitude lambda and latitude varphi as outlined here. In brief, after model initialization (otherwise orography would also be initialized, overwriting your changes)","category":"page"},{"location":"instructions/","page":"Instructions","title":"Instructions","text":"# set to a global constant\nset!(model, orography=0)\n\n# add two 2000m ridges at +-30˚E from 60˚S to 60˚N \nH, λ₀, φmax = 2000, 15, 60\nset!(model, orography=(λ,φ) -> 2λ₀ < λ < 360-2λ₀ || abs(φ) > φmax ? 0 : H*sind(180*λ/2λ₀)^2)\n\n# add a zonal ridge between 60˚E and 300˚E\nset!(model, orography=(λ,φ) -> λ > 4λ₀ && λ < 360-4λ₀ && abs(φ) < 20 ? H*cosd(3φ)^2 : 0, add=true)\n\n# add two Gaussian mountains\nλ1, λ2  = (120, 240)    # longitude positions [˚E]\nφ₀ = 45                 # latitude [˚N]\nσ = 5                   # width [˚]\n\n# first mountain, radius=360/2π to have distance in ˚ again (not meters)\nset!(model, orography=(λ,φ) -> H*exp(-spherical_distance((λ,φ), (λ1,φ₀), radius=360/2π)^2/2σ^2), add=true)\n\n# and add second\nset!(model, orography=(λ,φ) -> H*exp(-spherical_distance((λ,φ), (λ2,φ₀), radius=360/2π)^2/2σ^2), add=true)","category":"page"},{"location":"instructions/","page":"Instructions","title":"Instructions","text":"Whatever orography you construct, you can always check it with","category":"page"},{"location":"instructions/","page":"Instructions","title":"Instructions","text":"using CairoMakie\nheatmap(model.orography.orography, title=\"Orography [m]: Is it supposed to be a smiley?\")\nsave(\"smiley.png\", ans) # hide\nnothing # hide","category":"page"},{"location":"instructions/","page":"Instructions","title":"Instructions","text":"(Image: Orography)","category":"page"},{"location":"instructions/#Change-the-land-sea-mask","page":"Instructions","title":"Change the land-sea mask","text":"","category":"section"},{"location":"instructions/","page":"Instructions","title":"Instructions","text":"Similar to the orography you can change the land-sea mask. Find some more details here. Note that the land-sea mask does not have to agree with the orography, yes you can put an ocean on the top of Mount Everest! However, surface fluxes over land (as determined by the land-sea mask) are zero if the respective surface fields are NaN there. Meaning if you want to put an ocean on the top of Mount Everest you also will need to define the sea surface temperature there.","category":"page"},{"location":"instructions/","page":"Instructions","title":"Instructions","text":"For example, we could flood the southern hemisphere with","category":"page"},{"location":"instructions/","page":"Instructions","title":"Instructions","text":"# this will be automatically clamped back into [0, 1]\nset!(model, land_sea_mask=(λ, φ) -> φ < 0 ? -1 : 0, add=true)\n\nheatmap(model.land_sea_mask.mask, title=\"Land-sea mask with a southern hemisphere ocean\")\nsave(\"sh_ocean.png\", ans) # hide\nnothing # hide","category":"page"},{"location":"instructions/","page":"Instructions","title":"Instructions","text":"(Image: SH Ocean)","category":"page"},{"location":"instructions/#Change-the-surface-temperatures","page":"Instructions","title":"Change the surface temperatures","text":"","category":"section"},{"location":"instructions/","page":"Instructions","title":"Instructions","text":"By default, SpeedyWeather uses seasonally changing sea and land surface temperature coming from climatology, you can check this with","category":"page"},{"location":"instructions/","page":"Instructions","title":"Instructions","text":"model.ocean","category":"page"},{"location":"instructions/","page":"Instructions","title":"Instructions","text":"and for land","category":"page"},{"location":"instructions/","page":"Instructions","title":"Instructions","text":"model.land","category":"page"},{"location":"instructions/","page":"Instructions","title":"Instructions","text":"while you can use set!(simulation, sea_surface_temperature=...) to tweak the sea surface temperature (and similar for land_surface_temperature. both in Kelvin) as long as the model.ocean and model.land are set to seasonally changing your efforts will be quickly overwritten in the next time step as the \"ocean model\" and the \"land model\" component of SpeedyWeather evolve following the seasonal cycle. For a 20-day simulation these changes are not big, but mean you need to switch off that seasonal cycle and use constant temperatures instead. You do this with","category":"page"},{"location":"instructions/","page":"Instructions","title":"Instructions","text":"ocean = AquaPlanet(spectral_grid)","category":"page"},{"location":"instructions/","page":"Instructions","title":"Instructions","text":"and ","category":"page"},{"location":"instructions/","page":"Instructions","title":"Instructions","text":"temperature = ConstantLandTemperature(spectral_grid)\nland = LandModel(spectral_grid; temperature)","category":"page"},{"location":"instructions/","page":"Instructions","title":"Instructions","text":"which you can then pass on to the model constructor","category":"page"},{"location":"instructions/","page":"Instructions","title":"Instructions","text":"model = PrimitiveWetModel(spectral_grid; ocean, land)\nnothing # hide","category":"page"},{"location":"instructions/","page":"Instructions","title":"Instructions","text":"Now you have basically \"frozen\" the sea and land surface temperature in time, meaning you can tweak them with set! as before. For example, we could add a 2K in the \"North Atlantic\" with","category":"page"},{"location":"instructions/","page":"Instructions","title":"Instructions","text":"simulation = initialize!(model)\nset!(model, land_sea_mask=0)    # all ocean!\nset!(simulation, sea_surface_temperature=(λ, φ) -> (30 < φ < 60) && (270 < λ < 360) ? 2 : 0, add=true)\n\nsst = simulation.prognostic_variables.ocean.sea_surface_temperature\nheatmap(sst, title=\"SST with +2K in North Atlantic\")\nsave(\"sst_2K.png\", ans) # hide\nnothing # hide","category":"page"},{"location":"instructions/","page":"Instructions","title":"Instructions","text":"(Image: SST +2K)","category":"page"},{"location":"instructions/","page":"Instructions","title":"Instructions","text":"and similar for the land_surface_temperature in which case you would need to set the land-sea mask to 1 though, otherwise, while the land surface temperature is defined, there is not any land!","category":"page"},{"location":"instructions/#Change-the-initial-conditions","page":"Instructions","title":"Change the initial conditions","text":"","category":"section"},{"location":"instructions/","page":"Instructions","title":"Instructions","text":"Changing the initial conditions is somewhat more advanced but gives you way more options is therefore added here in case you want to be creative. But you can also use it to create an ensemble by simply adding some small random noise and check how quickly the trajectories diverge (butterfly effect) or check whether in any member it rains more or less. The prognostic variables are","category":"page"},{"location":"instructions/","page":"Instructions","title":"Instructions","text":"relative vorticity vor units of 1/s, typical values are 5 to 10e-5 for high and low pressure (which sign is which?) systems\ndivergence div, units of 1/s, similar scale\ntemperature temp, units of K\nlogarithm of surface pressure pres in units of Pascal, with typical values of 960-1040hPa before the logarithm\nhumidity humid, units of kg/kg, tropical surface values reach order of 10 g/kg.","category":"page"},{"location":"instructions/","page":"Instructions","title":"Instructions","text":"You can set them with","category":"page"},{"location":"instructions/","page":"Instructions","title":"Instructions","text":"set!(simulation, humid=0)","category":"page"},{"location":"instructions/","page":"Instructions","title":"Instructions","text":"to start with a dry atmosphere for example (how long does it take to rain when you do that?). You can use the same set! options as before, so maybe you can figure out","category":"page"},{"location":"instructions/","page":"Instructions","title":"Instructions","text":"how to add a storm?\nhow to start in a heatwave?","category":"page"},{"location":"instructions/","page":"Instructions","title":"Instructions","text":"Some more information on setting the initial conditions can be found here.","category":"page"},{"location":"new_to_julia/#New-to-Julia?","page":"New to Julia?","title":"New to Julia?","text":"","category":"section"},{"location":"new_to_julia/","page":"New to Julia?","title":"New to Julia?","text":"The following lists some useful links if you are new to Julia and want to use RainMaker.jl and SpeedyWeather.jl for education or research.","category":"page"},{"location":"new_to_julia/#Install-Julia","page":"New to Julia?","title":"Install Julia","text":"","category":"section"},{"location":"new_to_julia/","page":"New to Julia?","title":"New to Julia?","text":"First of all you have to install Julia, the recommended way is using the installation manager for Julia called Juliaup, see here","category":"page"},{"location":"new_to_julia/","page":"New to Julia?","title":"New to Julia?","text":"Install Julia","category":"page"},{"location":"new_to_julia/#Julia-kernel-for-Jupyter-notebooks","page":"New to Julia?","title":"Julia kernel for Jupyter notebooks","text":"","category":"section"},{"location":"new_to_julia/","page":"New to Julia?","title":"New to Julia?","text":"Then you may want to use Julia inside Jupyter Notebooks (the \"Ju\" in \"Jupyter\" is for Julia!) for this you need to install IJulia which you can do through Julia's built-in package manager Pkg.jl, this is as easy as","category":"page"},{"location":"new_to_julia/","page":"New to Julia?","title":"New to Julia?","text":"julia> ] add IJulia","category":"page"},{"location":"new_to_julia/","page":"New to Julia?","title":"New to Julia?","text":"where ] opens the package manger. After this installing a Julia kernel for Jupyter is just","category":"page"},{"location":"new_to_julia/","page":"New to Julia?","title":"New to Julia?","text":"julia> using IJulia\njulia> installkernel(\"Julia\")","category":"page"},{"location":"new_to_julia/","page":"New to Julia?","title":"New to Julia?","text":"and you can choose \"Julia\" as a kernel in a Jupyter notebook.","category":"page"},{"location":"new_to_julia/#Julia-documentation,-tutorials-and-community-resources","page":"New to Julia?","title":"Julia documentation, tutorials and community resources","text":"","category":"section"},{"location":"new_to_julia/","page":"New to Julia?","title":"New to Julia?","text":"JuliaLang documentation, particularly\nDifferences from Matlab/R/Python\nLearn Julia in y minutes\nJulia's discourse forum\nJoin the Julia slack and Zulip channel\nJulia's YouTube channel\nTutorials and books","category":"page"},{"location":"new_to_julia/#SpeedyWeather-documentation","page":"New to Julia?","title":"SpeedyWeather documentation","text":"","category":"section"},{"location":"new_to_julia/","page":"New to Julia?","title":"New to Julia?","text":"Because RainMaker.jl is built on top of SpeedyWeather.jl do have a look at the documentation therein which explains how to run and modify SpeedyWeather.","category":"page"},{"location":"new_to_julia/","page":"New to Julia?","title":"New to Julia?","text":"SpeedyWeather.jl documentation","category":"page"},{"location":"submit/#Submit-to-the-RainMaker-challenge","page":"Submit","title":"Submit to the RainMaker challenge","text":"","category":"section"},{"location":"submit/","page":"Submit","title":"Submit","text":"The easiest is to have a look a existing submissions listed in List of submissions and get some inspirations what else to change from RainMaker instructions. Submit by creating a pull request adding a julia script file_name.jl in the folder /submissions of the repository. This script contains your SpeedyWeather model setup including instructions to run the model so that the RainGauge records for 20 days for a 20-day challenge.","category":"page"},{"location":"submit/","page":"Submit","title":"Submit","text":"After executing this script there needs to be in the global scope of that script the following variables defined","category":"page"},{"location":"submit/","page":"Submit","title":"Submit","text":"a rain_gauge::RainGauge having measured precipitation\nan author::String, e.g. author = \"Kermit the Frog\"\na description::String describing your model setup in a few words, e.g. description = \"No orography\"","category":"page"},{"location":"submit/","page":"Submit","title":"Submit","text":"with those exact variable names. You can define anything else you want, e.g. rain_gauge2 but only rain_gauge would be used to evaluate your submission to the challenge. The rain gauge rain_gauge needs to be added to a SpeedyWeather simulation as outlined in Adding RainGauge as callback. The author and description strings are used in the List of submissions and the Leaderboard.","category":"page"},{"location":"submit/#Rules","page":"Submit","title":"Rules","text":"","category":"section"},{"location":"submit/","page":"Submit","title":"Submit","text":"All precipitation measured by the rain gauge has to be simulated by SpeedyWeather over a 20-day period.\nThe rain gauge must be placed at the agreed longitude and latitude coordinates.\nNo changes to the following physics inside SpeedyWeather: Large-scale condensation, convection, surface evaporation, or radiation.\nSea and land surface temperatures cannot exceed 305K anywhere during the simulation.\nThe simulation must remain stable over the 20-day period.","category":"page"},{"location":"#RainMaker","page":"Home","title":"RainMaker","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for RainMaker, a repository to measure precipitation inside a SpeedyWeather.jl simulation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Contents","category":"page"},{"location":"","page":"Home","title":"Home","text":"Installation\nNew to Julia?\nRainGauge\nRainMaker instructions\nSubmit to the RainMaker challenge\nRainMaker leaderboard\nList of submissions","category":"page"},{"location":"","page":"Home","title":"Home","text":"Older versions of the documentation correspond to previous challenges used for teaching, may have different rules, but can be looked up as an archive of submissions to the RainMaker challenge.","category":"page"},{"location":"","page":"Home","title":"Home","text":"RainMaker.jl v0.2.1: JuliaEO 2025, Terceira Island, Azores, January 2025\nRainMaker.jl v0.1.1: Intelligent Earth CDT, Oxford, November 2024","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"RainMaker.jl is an official Julia package, so to install the latest version you can simply type","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> ] add RainMaker","category":"page"},{"location":"","page":"Home","title":"Home","text":"Where ] opens Julia's package manager Pkg.jl which changes the prompt to (@v1.11) pkg>, exit the package manager with backspace. Pkg.jl is also a package itself, so you can alternatively do","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"RainMaker\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"RainMaker.jl depends on (among others)","category":"page"},{"location":"","page":"Home","title":"Home","text":"SpeedyWeather.jl\nMakie.jl and its backend CairoMakie for plotting","category":"page"},{"location":"","page":"Home","title":"Home","text":"While they are automatically installed, you will also want to install SpeedyWeather explicitly via","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> ] add SpeedyWeather","category":"page"},{"location":"","page":"Home","title":"Home","text":"or, again, using Pkg; Pkg.add(\"SpeedyWeather\"). So that ","category":"page"},{"location":"","page":"Home","title":"Home","text":"using SpeedyWeather","category":"page"},{"location":"","page":"Home","title":"Home","text":"also just works as dependencies are otherwise hidden for direct usage.","category":"page"},{"location":"leaderboard/#RainMaker-leaderboard","page":"Leaderboard","title":"RainMaker leaderboard","text":"","category":"section"},{"location":"leaderboard/","page":"Leaderboard","title":"Leaderboard","text":"The RainMaker leaderboard ranks submissions in /submissions to the RainMaker challenge by the amount of precipitation measured in a given location and over a certain period. To Submit to the RainMaker challenge see that section of the docs and particular the rules and formalities explained within. Also see List of submissions for a list of all submissions, their respective code and RainMaker plots Visualising RainGauge measurements.","category":"page"},{"location":"leaderboard/#Leaderboard","page":"Leaderboard","title":"Leaderboard","text":"","category":"section"},{"location":"leaderboard/","page":"Leaderboard","title":"Leaderboard","text":"Rank Author Description Location Total precipitation [mm] Share convection [%] Period [days]\n1 A Nicusan Evo opt unbounded (disqualified) 40.45˚N, -80.00˚E 505.956 74.0 15\n2 A Nicusan Evo opt bounded 40.45˚N, -80.00˚E 350.662 84.3 15\n3 Chris Rackauckas Brute Force OptimizationBBO DE 40.45˚N, -80.00˚E 344.814 84.8 15\n4 Anas NN Surrogate 40.45˚N, -80.00˚E 268.464 96.6 15\n5 Anas 200mm+ RainMaker 40.45˚N, -80.00˚E 211.204 89.1 15\n6 Gabriel Konar-Steenberg Brute force built on Anas surrogate 40.45˚N, -80.00˚E 211.164 89.1 15\n7 Theo D Kriging Surrogate with Latin Hypercube Sampling 40.45˚N, -80.00˚E 182.857 90.2 15\n8 Cameron Bieganek Latin hypercube search, no surrogate. 40.45˚N, -80.00˚E 179.765 93.4 15\n9 Chris Rackauckas Evotrees.jl Surrogate, Claude generated 40.45˚N, -80.00˚E 143.264 62.6 15\n10 Shirin Ermis Aqua-planet simulation with a mountain 40.45˚N, -80.00˚E 81.079 100.0 15\n11 Milan Aquaplanet 40.45˚N, -80.00˚E 23.902 92.5 15\n12 Tim Reichelt North Sea mountain 40.45˚N, -80.00˚E 10.709 0.0 15\n13 Milan default 40.45˚N, -80.00˚E 9.080 0.0 15\n14 Milan Atlantic mountain 40.45˚N, -80.00˚E 7.892 0.0 15","category":"page"},{"location":"rain_gauge/#RainGauge","page":"RainGauge","title":"RainGauge","text":"","category":"section"},{"location":"rain_gauge/","page":"RainGauge","title":"RainGauge","text":"RainMaker.jl exports the callback RainGauge, a rain gauge that you can place inside a SpeedyWeather simulation to measures precipitation at a given location. The following explains how to use this RainGauge callback. ","category":"page"},{"location":"rain_gauge/","page":"RainGauge","title":"RainGauge","text":"With a SpectralGrid from SpeedyWeather.jl (see here) you can create RainGauge (it needs to know the spectral grid to interpolate from gridded fields to a given location). In most cases you will probably want to specify the rain gauge's location with lond (0...360˚E, -180...180˚E also work) and latd (-90...90˚N)`","category":"page"},{"location":"rain_gauge/","page":"RainGauge","title":"RainGauge","text":"using SpeedyWeather, RainMaker\n\nspectral_grid = SpectralGrid()  # default resolution\nrain_gauge = RainGauge(spectral_grid, lond=358.75, latd=51.75)","category":"page"},{"location":"rain_gauge/","page":"RainGauge","title":"RainGauge","text":"(also see ?RainGauge for more information). The measurement_counter starts at 0 and just counts up the number of measurements the rain gauge has made, one per timestep – zero also means that the gauge is not initialized. In order to reconstruct the time axis the fields tstart and Δt are used but they will be automatically set when initialized given the time step in the model. At any time you can always reset!(rain_gauge) in order to reset the counter, time and all rainfall measurements. But a RainGauge is also mutable, meaning you can do this by hand too, e.g. rain_gauge.accumulated_rain_large_scale .= 0.","category":"page"},{"location":"rain_gauge/","page":"RainGauge","title":"RainGauge","text":"RainGauge has two vectors accumulated_rain_large_scale and accumulated_rain_convection where every entry is one measurement of the given precipitation type at the specified location. One measurement is taken after every time step of the model simulation. In order to preallocate these vectors we use max_measurements as length, meaning those are the maximum number of measurements that will be taken. An info is thrown when this point is reached and also an instance of RainGauge printed to the terminal shows you how many years of measurements you can take and how much of that measurement \"memory\" is already used, see above. If you want to measure for longer periods you may need to increase max_measurements by setting it as a keyword argument, e.g. RainGauge(spectral_grid, max_measurements=1_000_000)","category":"page"},{"location":"rain_gauge/#Adding-RainGauge-as-callback","page":"RainGauge","title":"Adding RainGauge as callback","text":"","category":"section"},{"location":"rain_gauge/","page":"RainGauge","title":"RainGauge","text":"The RainGauge is implemented as a <: SpeedyWeather.AbstractCallback (<: means \"subtype of\"). A Callback is an object (technically a struct introducing a new type that belongs to the supertype AbstractCallback) with methods defined that are executed after every time step of the model. A callback therefore allows you to inject any piece of code into a simulation. Many callbacks are \"diagnostic\" meaning they just read out variables but you could also define \"intrusive\" callbacks that change the model or the simulation while it is running (not covered here but see Intrusive callbacks).","category":"page"},{"location":"rain_gauge/","page":"RainGauge","title":"RainGauge","text":"A RainGauge can be added to a model with add!","category":"page"},{"location":"rain_gauge/","page":"RainGauge","title":"RainGauge","text":"model = PrimitiveWetModel(spectral_grid)\nadd!(model, rain_gauge)","category":"page"},{"location":"rain_gauge/","page":"RainGauge","title":"RainGauge","text":"Note that you can create many different (or same) RainGauges and add them all to your model in the same way. This way you can place several \"weather stations\" across the globe and measure simultaneously. Note that you will need to create several independent RainGauges for that, adding the same RainGauge several times to the model is unlikely what you will want to do (it will measure several times the same precipitation after each time step).","category":"page"},{"location":"rain_gauge/","page":"RainGauge","title":"RainGauge","text":"You can also delete! a RainGauge (or any callback) again, but you need to know its key for that which is printed to screen when added or just inspect","category":"page"},{"location":"rain_gauge/","page":"RainGauge","title":"RainGauge","text":"model.callbacks","category":"page"},{"location":"rain_gauge/","page":"RainGauge","title":"RainGauge","text":"then with delete!(model.callbacks, :callback_????) where :callback_???? is a Symbol (an immutable string) identifying the callback you want to delete.","category":"page"},{"location":"rain_gauge/#Continuous-measurements-across-simulations","page":"RainGauge","title":"Continuous measurements across simulations","text":"","category":"section"},{"location":"rain_gauge/","page":"RainGauge","title":"RainGauge","text":"While you can reset!(::RainGauge) your rain gauge manually every time, this will not happen automatically for a new simulation if the rain gauge has already measured. This is so that you can run one simulation, look at the rain gauge measurements and then continue the simulation. Let's try this by running two 10-day simulations.","category":"page"},{"location":"rain_gauge/","page":"RainGauge","title":"RainGauge","text":"simulation = initialize!(model)\nmodel.feedback.verbose = false # hide\nrun!(simulation, period=Day(10))\nrain_gauge","category":"page"},{"location":"rain_gauge/","page":"RainGauge","title":"RainGauge","text":"Yay, the rain gauge has measured precipitation, now let us continue","category":"page"},{"location":"rain_gauge/","page":"RainGauge","title":"RainGauge","text":"run!(simulation, period=Day(10))\nrain_gauge","category":"page"},{"location":"rain_gauge/","page":"RainGauge","title":"RainGauge","text":"which adds another 10 days of measurements as if we had simulated directly 20 days.","category":"page"},{"location":"rain_gauge/#Skipping-first-days","page":"RainGauge","title":"Skipping first days","text":"","category":"section"},{"location":"rain_gauge/","page":"RainGauge","title":"RainGauge","text":"After a rain_gauge has recorded one can skip the first n days (or any period) using the skip function, with period as second argument","category":"page"},{"location":"rain_gauge/","page":"RainGauge","title":"RainGauge","text":"rain_gauge_day10to20 = skip(rain_gauge, Day(10))","category":"page"},{"location":"rain_gauge/","page":"RainGauge","title":"RainGauge","text":"(or use skip! as its in-place version, changing the rain_gauge directly). In this case, skipping the first 10 days is somewhat equivalent to only measuring the second 10 days in the example from the previous section. However, skipping does not delete the measurements in the skipped period but normalizes the accumulated rainfall so that it is zero at the end of the skipped period. And consequently the accumulated rainfall is now negative at the start of the skipped period, this is better explained through a visualisation in the next section.","category":"page"},{"location":"rain_gauge/#Visualising-RainGauge-measurements","page":"RainGauge","title":"Visualising RainGauge measurements","text":"","category":"section"},{"location":"rain_gauge/","page":"RainGauge","title":"RainGauge","text":"While you always see a summary of a RainGauge printed to the REPL, we can also visualise all measurements nicely with Makie.jl. Because RainMaker.jl has this package as a dependency (particulary the CairoMakie backend) the only thing to do is calling the RainMaker.plot function. We do not export plot as it easily conflicts with other packages exporting a plot function.","category":"page"},{"location":"rain_gauge/","page":"RainGauge","title":"RainGauge","text":"using CairoMakie # hide\nRainMaker.plot(rain_gauge)\nsave(\"rain_gauge.png\", ans) # hide\nnothing # hide","category":"page"},{"location":"rain_gauge/","page":"RainGauge","title":"RainGauge","text":"(Image: Rain gauge plot)","category":"page"},{"location":"rain_gauge/","page":"RainGauge","title":"RainGauge","text":"The RainMaker.plot functions takes as optional keyword argument rate_Δt::Period so that you can change the binwidth of the precipitation rate. Above we have one bin every 6 hours (the default), showing the average rate over the previous 6 hours. You can visualise the hourly precipitation rate with","category":"page"},{"location":"rain_gauge/","page":"RainGauge","title":"RainGauge","text":"RainMaker.plot(rain_gauge, rate_Δt=Hour(1))\nsave(\"rain_gauge2.png\", ans) # hide\nnothing # hide","category":"page"},{"location":"rain_gauge/","page":"RainGauge","title":"RainGauge","text":"(Image: Rain gauge plot, hourly rate)","category":"page"},{"location":"rain_gauge/","page":"RainGauge","title":"RainGauge","text":"which just gives you a more fine-grained picture. Arguments can be Hour(::Real), Minute(::Real), Day(::Real) but note that the default model time step at default resolution is 30min, so you do not get any more information when going lower than that.","category":"page"},{"location":"rain_gauge/","page":"RainGauge","title":"RainGauge","text":"RainMaker.plot also allows to skip an initial period, see Skipping first days, which is equivalent to calling plot on a rain gauge which has already been skipped, e.g. RainMaker.plot(rain_gauge, skip=Day(10)) is the same as RainMaker.plot(skip(rain_gauge, Day(10))).","category":"page"},{"location":"rain_gauge/","page":"RainGauge","title":"RainGauge","text":"RainMaker.plot(rain_gauge, skip=Day(10))\nsave(\"rain_gauge_skip.png\", ans) # hide\nnothing # hide","category":"page"},{"location":"rain_gauge/","page":"RainGauge","title":"RainGauge","text":"(Image: Rain gauge plot, first 10 days skipped)","category":"page"},{"location":"rain_gauge/","page":"RainGauge","title":"RainGauge","text":"This plot nicely illustrates what it means to \"skip the first 10 days\": This does not delete measurements but it renormalizes the accumulated precipitation to start in the negative, crosses zero at the end of the skipped period. The total accumulated rainfall at the end of the full period is then equivalent as if no measurements would have taken place from day 0 to day 10 without actually erasing any data.","category":"page"},{"location":"rain_gauge/#Visualising-accumulated-rainfall-globally","page":"RainGauge","title":"Visualising accumulated rainfall globally","text":"","category":"section"},{"location":"rain_gauge/","page":"RainGauge","title":"RainGauge","text":"SpeedyWeather simulations diagnose the accumulated rainfall internally. Which is actually what a RainGauge reads out on every time step at the specified location (but see details in Discarding spin-up). This means you can also visualise a map of the accumulated rainfall since the beginning of the simulation to better understand regional rainfall patterns. SpeedyWeather uses largely SI units internally, but RainGauge converts meters to millimeters because that is the more common unit for rainfall. If we read out SpeedyWeather's fields manually we therefore have to do this conversion manually too. Total precipitation is the sum of convective and large-scale precipitation which we can calculate and visualise like this","category":"page"},{"location":"rain_gauge/","page":"RainGauge","title":"RainGauge","text":"# (; a, b) = struct unpacks the fields a, b in struct identified by name, equivalent to\n# a = struct.a and b = struct.b\n(; precip_large_scale, precip_convection) = simulation.diagnostic_variables.physics\ntotal_precipitation = precip_large_scale + precip_convection\ntotal_precipitation *= 1000    # convert m to mm\n\nusing CairoMakie\nheatmap(total_precipitation, title=\"Total precipitation [mm], accumulated\")\nsave(\"total_precip_map.png\", ans) # hide\nnothing # hide","category":"page"},{"location":"rain_gauge/","page":"RainGauge","title":"RainGauge","text":"(Image: Map of total accumulated precipitation)","category":"page"},{"location":"rain_gauge/","page":"RainGauge","title":"RainGauge","text":"You can also visualise these fields individually. The accumulation starts when the model is initialized with simulation = initialize!(model) which constructs variables, initialized with zeros, too. This means the accumulation will continue across several run! calls unless you manually set it back via","category":"page"},{"location":"rain_gauge/","page":"RainGauge","title":"RainGauge","text":"simulation.diagnostic_variables.physics.precip_large_scale .= 0\nsimulation.diagnostic_variables.physics.precip_convection .= 0\nnothing # hide","category":"page"},{"location":"rain_gauge/","page":"RainGauge","title":"RainGauge","text":"The . here is important to specify the broadcasting of the scalar 0 on the right to the array on the left. This was not needed in *= 1000 above as scalar times vector/matrix is mathematicall already well defined.","category":"page"},{"location":"rain_gauge/#Discarding-spin-up","page":"RainGauge","title":"Discarding spin-up","text":"","category":"section"},{"location":"rain_gauge/","page":"RainGauge","title":"RainGauge","text":"A RainGauge starts measuring accumulated rainfall relative to the first run!(simulation) call after it has been added to the model with add!, see Adding RainGauge as callback. This means that you can run a simulation without a RainGauge and then only start measuring precipitation after some time has passed. You can use this to discard any spin-up ( = adjustment after initial conditions) of a simulation. Let us illustrate this","category":"page"},{"location":"rain_gauge/","page":"RainGauge","title":"RainGauge","text":"model = PrimitiveWetModel(spectral_grid)\n\n# add one rain gauge the measures the whole simulation\nrain_gauge_from_beginning  = RainGauge(spectral_grid, lond=-1.25, latd=51.75)\nadd!(model, rain_gauge_from_beginning)\n\nsimulation = initialize!(model)\nrun!(simulation, period=Week(1))\n\n# add another rain gauge that only starts measuring\n# after that week we already simulated\nrain_gauge_after_spinup  = RainGauge(spectral_grid, lond=-1.25, latd=51.75)\nadd!(model, rain_gauge_after_spinup)\nrun!(simulation, period=Day(10))\n\n# now compare them, from the beginning\nrain_gauge_from_beginning","category":"page"},{"location":"rain_gauge/","page":"RainGauge","title":"RainGauge","text":"versus","category":"page"},{"location":"rain_gauge/","page":"RainGauge","title":"RainGauge","text":"# rain gauge after a 1-week spinup\nrain_gauge_after_spinup","category":"page"},{"location":"rain_gauge/","page":"RainGauge","title":"RainGauge","text":"As you can see their clocks differ and so does the measured precipitation!","category":"page"},{"location":"rain_gauge/#Functions-and-types","page":"RainGauge","title":"Functions and types","text":"","category":"section"},{"location":"rain_gauge/","page":"RainGauge","title":"RainGauge","text":"","category":"page"},{"location":"rain_gauge/#RainMaker.RainGauge","page":"RainGauge","title":"RainMaker.RainGauge","text":"Measures convective and large-scale precipitation across time at one given location with linear interpolation from model grids onto lond, latd. Fields are \n\nlond::Float64: [OPTION] Longitude [0 to 360˚E] where to measure precipitation.\nlatd::Float64: [OPTION] Latitude [-90˚ to 90˚N] where to measure precipitation.\ninterpolator::Any: [OPTION] To interpolate precipitation fields onto lond, latd.\nmax_measurements::Int64: [OPTION] Maximum number of time steps used to allocate memory.\nmeasurement_counter::Int64: [OPTION] Measurement counter (one per time step), starting at 0 for uninitialized.\ntstart::DateTime: Start time of gauge.\nΔt::Second: Spacing between time steps.\naccumulated_rain_large_scale_start::Any: Accumulated large-scale precipitation [mm] in the simulation at the beginning of rain gauge measurements.\naccumulated_rain_convection_start::Any: Accumulated large-scale precipitation [mm] in the simulation at the beginning of rain gauge measurements.\naccumulated_rain_large_scale::Vector: Accumulated large-scale precipitation [mm].\naccumulated_rain_convection::Vector: Accumulated convective precipitation [mm].\n\n\n\n\n\n","category":"type"},{"location":"rain_gauge/#RainMaker.plot-Tuple{RainGauge}","page":"RainGauge","title":"RainMaker.plot","text":"plot(gauge::RainGauge; skip, rate_Δt) -> Figure\n\n\nPlot accumulated precipitation and precipitation rate across time for gauge::RainGauge from RainMaker.jl. rate_Δt specifies the interval used to bin the precipitation rate, while units are always converted to mm/day. Default is 6 hours.\n\n\n\n\n\n","category":"method"},{"location":"rain_gauge/#RainMaker.reset!-Tuple{RainGauge, PrognosticVariables, DiagnosticVariables, AbstractModel}","page":"RainGauge","title":"RainMaker.reset!","text":"reset!(\n    gauge::RainGauge,\n    progn::PrognosticVariables,\n    diagn::DiagnosticVariables,\n    model::AbstractModel\n)\n\n\nReset gauge::RainGauge to its initial state, but use time and Δt from clock.\n\n\n\n\n\n","category":"method"},{"location":"rain_gauge/#RainMaker.reset!-Tuple{RainGauge}","page":"RainGauge","title":"RainMaker.reset!","text":"reset!(gauge::RainGauge) -> RainGauge\n\n\nReset gauge::RainGauge to its initial state, i.e. set measurement_counter to 0, tstart to DEFAULT_DATE, Δt to DEFAULT_ΔT, and set accumulated precipitation vector to zeros.\n\n\n\n\n\n","category":"method"},{"location":"rain_gauge/#RainMaker.skip!-Tuple{RainGauge, Period}","page":"RainGauge","title":"RainMaker.skip!","text":"skip!(\n    rain_gauge::RainGauge,\n    period::Period\n) -> Union{Nothing, RainGauge}\n\n\nRenormalize a rain_gauge to skip the first period (e.g. 5 days) of measurements.\n\n\n\n\n\n","category":"method"},{"location":"rain_gauge/#SpeedyWeather.callback!-Tuple{RainGauge, PrognosticVariables, DiagnosticVariables, AbstractModel}","page":"RainGauge","title":"SpeedyWeather.callback!","text":"callback!(\n    gauge::RainGauge,\n    progn::PrognosticVariables,\n    diagn::DiagnosticVariables,\n    model::AbstractModel\n)\n\n\nCallback definition for gauge::RainGauge from RainMaker.jl. Interpolates large-scale and convective precipitation to the gauge's storage vectors and converts units from m to mm. Stops measuring if the max_measurements are reached which is printed only once as info.\n\n\n\n\n\n","category":"method"},{"location":"rain_gauge/#SpeedyWeather.initialize!-Tuple{RainGauge, Vararg{Any}}","page":"RainGauge","title":"SpeedyWeather.initialize!","text":"initialize!(\n    gauge::RainGauge,\n    args...\n) -> Union{Nothing, RainGauge}\n\n\nInitialize gauge::RainGauge by calling reset!(::RainGauge) but only if gauge is not already initialized (gauge.measurement_counter > 0), so that it can be re-used across several simulation runs.\n\n\n\n\n\n","category":"method"}]
}
